<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[阿里java规约(三)-单元测试.md]]></title>
    <url>%2F2018%2F02%2F09%2F%E9%98%BF%E9%87%8Cjava%E8%A7%84%E7%BA%A6%2F%E9%98%BF%E9%87%8Cjava%E8%A7%84%E7%BA%A6(%E4%B8%89)-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[单元测试(16)强制(7) 【强制】好的单元测试必须遵守 AIR 原则。 说明： 单元测试在线上运行时，感觉像空气（ AIR） 一样并不存在，但在测试质量的保障上，却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。 A： Automatic（自动化） I： Independent（独立性） R： Repeatable（可重复） 【强制】单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的，执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。单元测试中不准使用 System.out 来进行人肉验证，必须使用 assert 来验证。 【强制】保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。 反例： method2 需要依赖 method1 的执行， 将执行结果作为 method2 的输入。 【强制】单元测试是可以重复执行的，不能受到外界环境的影响。 说明： 单元测试通常会被放到持续集成中，每次有代码 check in 时单元测试都会被执行。如果单测对外部环境（网络、服务、中间件等） 有依赖，容易导致持续集成机制的不可用。 正例： 为了不受外界环境影响，要求设计代码时就把 SUT 的依赖改成注入，在测试时用 spring这样的 DI 框架注入一个本地（内存）实现或者 Mock 实现。 【强制】对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单测粒度至多是类级别，一般是方法级别。 说明： 只有测试粒度小才能在出错时尽快定位到出错位置。单测不负责检查跨类或者跨系统的交互逻辑，那是集成测试的领域。 【强制】核心业务、核心应用、核心模块的增量代码确保单元测试通过。 说明： 新增代码及时补充单元测试，如果新增代码影响了原有单元测试，请及时修正。 【强制】单元测试代码必须写在如下工程目录： src/test/java，不允许写在业务代码目录下。 说明： 源码构建时会跳过此目录，而单元测试框架默认是扫描此目录。 推荐(7) 【推荐】单元测试的基本目标：语句覆盖率达到 70%；核心模块的语句覆盖率和分支覆盖率都要达到 100% 说明： 在工程规约的应用分层中提到的 DAO 层， Manager 层，可重用度高的 Service，都应该进行单元测试。 【推荐】编写单元测试代码遵守 BCDE 原则，以保证被测试模块的交付质量。 B： Border，边界值测试，包括循环边界、特殊取值、 特殊时间点、数据顺序等。 C： Correct，正确的输入，并得到预期的结果。 D： Design，与设计文档相结合，来编写单元测试。 E： Error，强制错误信息输入（如：非法数据、异常流程、非业务允许输入等），并得到预期的结果。 【推荐】对于数据库相关的查询，更新，删除等操作，不能假设数据库里的数据是存在的，或者直接操作数据库把数据插入进去，请使用程序插入或者导入数据的方式来准备数据。 反例： 删除某一行数据的单元测试，在数据库中， 先直接手动增加一行作为删除目标，但是这一行新增数据并不符合业务插入规则， 导致测试结果异常。 【推荐】和数据库相关的单元测试，可以设定自动回滚机制，不给数据库造成脏数据。或者对单元测试产生的数据有明确的前后缀标识。 正例： 在 RDC 内部单元测试中，使用 RDC_UNITTEST的前缀标识数据。 【推荐】对于不可测的代码建议做必要的重构，使代码变得可测，避免为了达到测试要求而书写不规范测试代码。 【推荐】在设计评审阶段，开发人员需要和测试人员一起确定单元测试范围，单元测试最好覆盖所有测试用例（ UC）。 【推荐】单元测试作为一种质量保障手段，不建议项目发布后补充单元测试用例，建议在项目提测前完成单元测试。 参考(2) 【参考】为了更方便地进行单元测试，业务代码应避免以下情况： 构造方法中做的事情过多。 存在过多的全局变量和静态方法。 存在过多的外部依赖。 存在过多的条件语句。 说明： 多层条件语句建议使用卫语句、策略模式、状态模式等方式重构。 【参考】不要对单元测试存在如下误解： 那是测试同学干的事情。本文是开发手册，凡是本文内容都是与开发同学强相关的。 单元测试代码是多余的。 汽车的整体功能与各单元部件的测试正常与否是强相关的。 单元测试代码不需要维护。一年半载后，那么单元测试几乎处于废弃状态。 单元测试与线上故障没有辩证关系。好的单元测试能够最大限度地规避线上故障。]]></content>
      <categories>
        <category>阿里java规约</category>
      </categories>
      <tags>
        <tag>阿里java规约</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里java规约(二)-异常日志(1)-异常处理.md]]></title>
    <url>%2F2018%2F02%2F09%2F%E9%98%BF%E9%87%8Cjava%E8%A7%84%E7%BA%A6%2F%E9%98%BF%E9%87%8Cjava%E8%A7%84%E7%BA%A6(%E4%BA%8C)-%E5%BC%82%E5%B8%B8%E6%97%A5%E5%BF%97(1)-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[异常处理(13)强制(8) 【强制】 Java 类库中定义的可以通过预检查方式规避的 RuntimeException 异常不应该通过catch 的方式来处理，比如： NullPointerException， IndexOutOfBoundsException 等等。 说明： 无法通过预检查的异常除外，比如，在解析字符串形式的数字时，不得不通过 catch NumberFormatException 来实现。 正例： if (obj != null) {…} 反例： try { obj.method() } catch (NullPointerException e) {…} 【强制】异常不要用来做流程控制，条件控制。 说明： 异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多。 【强制】 catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。 说明： 对大段代码进行 try-catch，使程序无法根据不同的异常做出正确的应激反应，也不利于定位问题，这是一种不负责任的表现。 正例： 用户注册的场景中，如果用户输入非法字符， 或用户名称已存在， 或用户输入密码过于简单，在程序上作出分门别类的判断，并提示给用户。 【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。 【强制】有 try 块放到了事务代码中， catch 异常后，如果需要回滚事务，一定要注意手动回滚事务。 【强制】 finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。 说明： 如果 JDK7 及以上，可以使用 try-with-resources 方式。 【强制】不要在 finally 块中使用 return。 说明： finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句。 【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。 说明： 如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。 推荐(4) 【推荐】方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回 null 值。 说明： 本手册明确防止 NPE 是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、 序列化失败、 运行时异常等场景返回null 的情况。 【推荐】防止 NPE，是程序员的基本修养，注意 NPE 产生的场景： 1）返回类型为基本数据类型， return 包装数据类型的对象时，自动拆箱有可能产生 NPE。 反例： public int f() { return Integer 对象}， 如果为 null，自动解箱抛 NPE。 2） 数据库的查询结果可能为 null。 3） 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。 4） 远程调用返回对象时，一律要求进行空指针判断，防止 NPE。 5） 对于 Session 中获取的数据， 建议 NPE 检查，避免空指针。 6） 级联调用 obj.getA().getB().getC()； 一连串调用，易产生 NPE。 正例： 使用 JDK8 的 Optional 类来防止 NPE 问题。 【推荐】定义时区分 unchecked / checked 异常，避免直接抛出 new RuntimeException()，更不允许抛出 Exception 或者 Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如： DAOException / ServiceException 等。 参考(1) 【 参考】 对于公司外的 http/api 开放接口必须使用“错误码”； 而应用内部推荐异常抛出；跨应用间 RPC 调用优先考虑使用 Result 方式，封装 isSuccess()方法、 “错误码”、 “错误简短信息”。 说明： 关于 RPC 方法返回方式使用 Result 方式的理由： 1） 使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。 2） 如果不加栈信息，只是 new 自定义异常，加入自己的理解的 error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。 【参考】 避免出现重复的代码（ Don’t Repeat Yourself） ，即 DRY 原则。 说明： 随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是组件化。 正例： 一个类中有多个 public 方法，都需要进行数行相同的参数校验操作，这个时候请抽取： private boolean checkParam(DTO dto) {…}]]></content>
      <categories>
        <category>阿里java规约</category>
      </categories>
      <tags>
        <tag>阿里java规约</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里java规约(二)-异常日志(2)-日志规约.md]]></title>
    <url>%2F2018%2F02%2F09%2F%E9%98%BF%E9%87%8Cjava%E8%A7%84%E7%BA%A6%2F%E9%98%BF%E9%87%8Cjava%E8%A7%84%E7%BA%A6(%E4%BA%8C)-%E5%BC%82%E5%B8%B8%E6%97%A5%E5%BF%97(2)-%E6%97%A5%E5%BF%97%E8%A7%84%E7%BA%A6%2F</url>
    <content type="text"><![CDATA[日志规约(8)强制(6) 【强制】应用中不可直接使用日志系统（ Log4j、 Logback） 中的 API，而应依赖使用日志框架SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。 123import org.slf4j.Logger;import org.slf4j.LoggerFactory;private static final Logger logger = LoggerFactory.getLogger(Abc.class); 【强制】日志文件推荐至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。 【强制】应用中的扩展日志（ 如打点、临时监控、访问日志等） 命名方式： appName_logType_logName.log。 logType:日志类型，推荐分类有 stats/monitor/visit 等； logName:日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。 正例： mppserver 应用中单独监控时区转换异常，如：mppserver_monitor_timeZoneConvert.log 说明： 推荐对日志进行分类， 如将错误日志和业务日志分开存放，便于开发人员查看，也便于通过日志对系统进行及时监控。 【强制】对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方式。 说明： logger.debug(“Processing trade with id: “ + id + “ and symbol: “ + symbol); 如果日志级别是 warn，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol 是对象，会执行 toString()方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。 正例： （ 条件） 123if (logger.isDebugEnabled()) &#123; logger.debug("Processing trade with id: " + id + " and symbol: " + symbol);&#125; 正例： （ 占位符） 1logger.debug("Processing trade with id: &#123;&#125; and symbol : &#123;&#125; ", id, symbol); 【强制】避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity=false。 正例： 【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 throws 往上抛出。 正例： logger.error(各类参数或者对象 toString + “_” + e.getMessage(), e); 推荐(2) 【推荐】谨慎地记录日志。生产环境禁止输出 debug 日志； 有选择地输出 info 日志； 如果使用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。 说明： 大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。 记录日志时请思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？ 【推荐】可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。如非必要，请不要在此场景打出 error 级别，避免频繁报警。 说明： 注意日志输出的级别， error 级别只记录系统逻辑出错、异常或者重要的错误信息。]]></content>
      <categories>
        <category>阿里java规约</category>
      </categories>
      <tags>
        <tag>阿里java规约</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里java规约(一)-编程规约(9)-其他.md]]></title>
    <url>%2F2018%2F02%2F09%2F%E9%98%BF%E9%87%8Cjava%E8%A7%84%E7%BA%A6%2F%E9%98%BF%E9%87%8Cjava%E8%A7%84%E7%BA%A6(%E4%B8%80)-%E7%BC%96%E7%A8%8B%E8%A7%84%E7%BA%A6(9)-%E5%85%B6%E4%BB%96%2F</url>
    <content type="text"><![CDATA[其他(8)强制(5) 【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。 说明： 不要在方法体内定义： Pattern pattern = Pattern.compile(规则); 【强制】 velocity 调用 POJO 类的属性时，建议直接使用属性名取值即可，模板引擎会自动按规范调用 POJO 的 getXxx()，如果是 boolean 基本数据类型变量（ boolean 命名不需要加 is前缀） ，会自动调用 isXxx()方法。 说明： 注意如果是 Boolean 包装类对象，优先调用 getXxx()的方法。 【强制】后台输送给页面的变量必须加$!{var}——中间的感叹号。 说明： 如果 var=null 或者不存在，那么${var}会直接显示在页面上。 【强制】注意 Math.random() 这个方法返回是 double 类型，注意取值的范围 0≤x&lt;1（ 能够取到零值，注意除零异常） ，如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。 【强制】获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime(); 说明： 如果想获取更加精确的纳秒级时间值， 使用 System.nanoTime()的方式。在 JDK8 中，针对统计时间等场景，推荐使用 Instant 类。 推荐(3) 【推荐】 不要在视图模板中加入任何复杂的逻辑。 说明： 根据 MVC 理论，视图的职责是展示，不要抢模型和控制器的活。 【推荐】 任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。 【推荐】 及时清理不再使用的代码段或配置信息。 说明： 对于垃圾代码或过时配置，坚决清理干净，避免程序过度臃肿，代码冗余。 正例： 对于暂时被注释掉，后续可能恢复使用的代码片断，在注释代码上方，统一规定使用三个斜杠(///)来说明注释掉代码的理由。]]></content>
      <categories>
        <category>阿里java规约</category>
      </categories>
      <tags>
        <tag>阿里java规约</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里java规约(一)-编程规约(8)-注释规约.md]]></title>
    <url>%2F2018%2F02%2F09%2F%E9%98%BF%E9%87%8Cjava%E8%A7%84%E7%BA%A6%2F%E9%98%BF%E9%87%8Cjava%E8%A7%84%E7%BA%A6(%E4%B8%80)-%E7%BC%96%E7%A8%8B%E8%A7%84%E7%BA%A6(8)-%E6%B3%A8%E9%87%8A%E8%A7%84%E7%BA%A6%2F</url>
    <content type="text"><![CDATA[注释规约(11)强制(6) 【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用/*内容/格式，不得使用// xxx 方式。 说明： 在 IDE 编辑窗口中， Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注释； 在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。 【强制】所有的抽象方法（ 包括接口中的方法） 必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。 说明： 对子类的实现要求，或者调用注意事项，请一并说明。 【强制】所有的类都必须添加创建者和创建日期。 【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/ /注释，注意与代码对齐。 【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。 推荐(2) 【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。 反例： “TCP 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。 【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。 说明： 代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，就失去了导航的意义。 参考(5) 【参考】 谨慎注释掉代码。 在上方详细说明，而不是简单地注释掉。 如果无用，则删除。 说明： 代码被注释掉有两种可能性： 1） 后续会恢复此段代码逻辑。 2） 永久不用。前者如果没有备注信息，难以知晓注释动机。后者建议直接删掉（ 代码仓库保存了历史代码） 。 【参考】对于注释的要求： 第一、能够准确反应设计思想和代码逻辑； 第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。 完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路； 注释也是给继任者看的，使其能够快速接替自己的工作。 【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。 反例：// put elephant into fridgeput(elephant, fridge);方法名 put，加上两个有意义的变量名 elephant 和 fridge，已经说明了这是在干什么，语义清晰的代码不需要额外的注释。 【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。 1） 待办事宜（ TODO） :（标记人，标记时间， [预计处理时间]）表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc还没有实现，但已经被广泛使用。只能应用于类，接口和方法（ 因为它是一个 Javadoc 标签）。 2） 错误，不能工作（ FIXME） :（ 标记人，标记时间， [预计处理时间]）在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。]]></content>
      <categories>
        <category>阿里java规约</category>
      </categories>
      <tags>
        <tag>阿里java规约</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里java规约(一)-编程规约(7)-控制语句.md]]></title>
    <url>%2F2018%2F02%2F09%2F%E9%98%BF%E9%87%8Cjava%E8%A7%84%E7%BA%A6%2F%E9%98%BF%E9%87%8Cjava%E8%A7%84%E7%BA%A6(%E4%B8%80)-%E7%BC%96%E7%A8%8B%E8%A7%84%E7%BA%A6(7)-%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[控制语句(10)强制(3) 【强制】在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止； 在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使空代码。 【强制】在 if/else/for/while/do 语句中必须使用大括号。 即使只有一行代码，避免采用单行的编码方式： if (condition) statements; 【强制】在高并发场景中，避免使用”等于”判断作为中断或退出的条件。 说明： 如果并发控制没有处理好，容易产生等值判断被“击穿”的情况，使用大于或小于的区间判断条件来代替。 反例： 判断剩余奖品数量等于 0 时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变成了负数， 这样的话，活动无法终止。 推荐(5) 【推荐】表达异常的分支时，少用 if-else 方式，这种方式可以改写成： 12345if (condition) &#123; ... return obj;&#125;// 接着写 else 的业务逻辑代码; 说明： 如果非得使用 if()…else if()…else…方式表达逻辑，【强制】 避免后续代码维护困难， 请勿超过 3 层。 正例： 超过 3 层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，其中卫语句示例如下：123456789101112public void today() &#123; if (isBusy()) &#123; System.out.println(“change time.”); return; &#125; if (isFree()) &#123; System.out.println(“go to travel.”); return; &#125; System.out.println(“stay at home to learn Alibaba Java Coding Guidelines.”); return;&#125; 【推荐】除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。 说明： 很多 if 语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？ 正例： 12345// 伪代码如下final boolean existed = (file.open(fileName, "w") != null) &amp;&amp; (...) || (...);if (existed) &#123; ...&#125; 反例： 123if ((file.open(fileName, "w") != null) &amp;&amp; (...) || (...)) &#123; ...&#125; 【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 try-catch 操作（ 这个 try-catch 是否可以移至循环体外） 。 【推荐】避免采用取反逻辑运算符。 说明： 取反逻辑不利于快速理解，并且取反逻辑写法必然存在对应的正向逻辑写法。 正例： 使用 if (x &lt; 628) 来表达 x 小于 628。 反例： 使用 if (!(x &gt;= 628)) 来表达 x 小于 628。 【推荐】接口入参保护，这种场景常见的是用作批量操作的接口。 参考(2) 【参考】下列情形，需要进行参数校验： 1） 调用频次低的方法。 2） 执行时间开销很大的方法。 此情形中， 参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退，或者错误，那得不偿失。 3） 需要极高稳定性和可用性的方法。 4） 对外提供的开放接口，不管是 RPC/API/HTTP 接口。 5） 敏感权限入口。 【参考】下列情形， 不需要进行参数校验： 1） 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求。 2） 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一台服务器中，所以 DAO 的参数校验，可以省略。 3） 被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。]]></content>
      <categories>
        <category>阿里java规约</category>
      </categories>
      <tags>
        <tag>阿里java规约</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里java规约(一)-编程规约(6)-并发处理.md]]></title>
    <url>%2F2018%2F02%2F09%2F%E9%98%BF%E9%87%8Cjava%E8%A7%84%E7%BA%A6%2F%E9%98%BF%E9%87%8Cjava%E8%A7%84%E7%BA%A6(%E4%B8%80)-%E7%BC%96%E7%A8%8B%E8%A7%84%E7%BA%A6(6)-%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[并发处理(15)强制(9) 【强制】 获取单例对象需要保证线程安全，其中的方法也要保证线程安全。 说明： 资源驱动类、工具类、单例工厂类都需要注意。 【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。 正例： 12345public class TimerTaskThread extends Thread &#123; public TimerTaskThread() &#123; super.setName("TimerTaskThread"); ... &#125; 【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。 说明： 使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。 【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明： Executors 返回的线程池对象的弊端如下： 1） FixedThreadPool 和 SingleThreadPool: 允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。 2） CachedThreadPool 和 ScheduledThreadPool: 允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。 【强制】 SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为static，必须加锁，或者使用 DateUtils 工具类。 正例： 注意线程安全，使用 DateUtils。亦推荐如下处理： 123456private static final ThreadLocal&lt;DateFormat&gt; df = new ThreadLocal&lt;DateFormat&gt;() &#123; @Override protected DateFormat initialValue() &#123; return new SimpleDateFormat("yyyy-MM-dd"); &#125;&#125;; 说明： 如果是 JDK8 的应用，可以使用 Instant 代替 Date， LocalDateTime 代替 Calendar，DateTimeFormatter 代替 SimpleDateFormat，官方给出的解释： simple beautiful strong immutable thread-safe。 【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁； 能锁区块，就不要锁整个方法体； 能用对象锁，就不要用类锁。 说明： 尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用 RPC 方法。 【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。 说明： 线程一需要对表 A、 B、 C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 A、 B、 C，否则可能出现死锁。 【强制】并发修改同一记录时，避免更新丢失， 需要加锁。 要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。 说明： 如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 3 次。 【强制】多线程并行处理定时任务时， Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。 推荐(3) 【推荐】使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown方法，线程执行代码注意 catch 异常，确保 countDown 方法被执行到，避免主线程无法执行至 await 方法，直到超时才返回结果。 说明： 注意，子线程抛出异常堆栈，不能在主线程 try-catch 到。 【推荐】避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降。 说明： Random 实例包括 java.util.Random 的实例或者 Math.random()的方式。 正例： 在 JDK7 之后，可以直接使用 API ThreadLocalRandom， 而在 JDK7 之前， 需要编码保证每个线程持有一个实例。 【推荐】 在并发场景下， 通过双重检查锁（ double-checked locking） 实现延迟初始化的优化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration)， 推荐解决方案中较为简单一种（ 适用于 JDK5 及以上版本） ，将目标属性声明为 volatile 型。 反例： 1234567891011class Singleton &#123; private Helper helper = null; public Helper getHelper() &#123; if (helper == null) synchronized(this) &#123; if (helper == null) helper = new Helper(); &#125; return helper; &#125; // other methods and fields...&#125; 参考(3) 【参考】 volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。如果是 count++操作，使用如下类实现：AtomicInteger count = new AtomicInteger(); count.addAndGet(1);如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好（ 减少乐观锁的重试次数）。 【参考】 HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中可以使用其它数据结构或加锁来规避此风险。 【参考】 ThreadLocal 无法解决共享对象的更新问题， ThreadLocal 对象建议使用 static修饰。这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享此静态变量 ，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量。]]></content>
      <categories>
        <category>阿里java规约</category>
      </categories>
      <tags>
        <tag>阿里java规约</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里java规约(一)-编程规约(5)-集合处理.md]]></title>
    <url>%2F2018%2F02%2F09%2F%E9%98%BF%E9%87%8Cjava%E8%A7%84%E7%BA%A6%2F%E9%98%BF%E9%87%8Cjava%E8%A7%84%E7%BA%A6(%E4%B8%80)-%E7%BC%96%E7%A8%8B%E8%A7%84%E7%BA%A6(5)-%E9%9B%86%E5%90%88%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[集合处理(13)强制(8) 【强制】 关于 hashCode 和 equals 的处理，遵循如下规则： 1） 只要重写 equals，就必须重写 hashCode。 2） 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写这两个方法。 3） 如果自定义对象作为 Map 的键，那么必须重写 hashCode 和 equals。 说明： String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象作为 key 来使用。 【强制】 ArrayList的subList结果不可强转成ArrayList，否则会抛出 ClassCastException异常， 即 java.util.RandomAccessSubList cannot be cast to java.util.ArrayList. 说明： subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList ，而是ArrayList 的一个视图，对于 SubList 子列表的所有操作最终会反映到原列表上。 【强制】在 subList 场景中， 高度注意对原集合元素个数的修改，会导致子列表的遍历、增加、删除均会产生 ConcurrentModificationException 异常。 【强制】使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一样的数组，大小就是 list.size()。 说明： 使用 toArray 带参方法，入参分配的数组空间不够大时， toArray 方法内部将重新分配内存空间，并返回新数组地址； 如果数组元素个数大于实际所需，下标为[ list.size() ]的数组元素将被置为 null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致。 正例： 12345List&lt;String&gt; list = new ArrayList&lt;String&gt;(2);list.add("guan");list.add("bao");String[] array = new String[list.size()];array = list.toArray(array); 反例： 直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它类型数组将出现 ClassCastException 错误。 【强制】使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。 说明： asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。 1234String[] str = new String[] &#123; "you", "wu" &#125;;List list = Arrays.asList(str);第一种情况： list.add("yangguanbao"); 运行时异常。第二种情况： str[0] = "gujin"; 那么 list.get(0)也会随之修改。 【强制】泛型通配符&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用 add 方法， 而&lt;? super T&gt;不能使用 get 方法，作为接口调用赋值时易出错。 说明： 扩展说一下 PECS(Producer Extends Consumer Super)原则： 第一、 频繁往外读取内容的，适合用&lt;? extends T&gt;。 第二、 经常往里插入的，适合用&lt;? super T&gt;。 【强制】不要在 foreach 循环里进行元素的 remove/add 操作。 remove 元素请使用 Iterator方式，如果并发操作，需要对 Iterator 对象加锁。 正例： 1234567Iterator&lt;String&gt; iterator = list.iterator();while (iterator.hasNext()) &#123; String item = iterator.next(); if (删除元素的条件) &#123; iterator.remove(); &#125;&#125; 反例： 12345678List&lt;String&gt; list = new ArrayList&lt;String&gt;();list.add("1");list.add("2");for (String item : list) &#123; if ("1".equals(item)) &#123; list.remove(item); &#125;&#125; 说明： 以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗？ 【强制】在 JDK7 版本及以上， Comparator 要满足如下三个条件，不然 Arrays.sort，Collections.sort 会报 IllegalArgumentException 异常。 说明： 三个条件如下 1） x， y 的比较结果和 y， x 的比较结果相反。 2） x&gt;y， y&gt;z， 则 x&gt;z。 3） x=y， 则 x， z 比较结果和 y， z 比较结果相同。 反例： 下例中没有处理相等的情况，实际使用中可能会出现异常： 123456new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; return o1.getId() &gt; o2.getId() ? 1 : -1; &#125;&#125;; 推荐(3) 【推荐】集合初始化时， 指定集合初始值大小。 说明：HashMap 使用 HashMap(int initialCapacity) 初始化， 正例：initialCapacity = (需要存储的元素个数 / 负载因子) + 1。注意负载因子 （ 即 loaderfactor） 默认为 0.75， 如果暂时无法确定初始值大小，请设置为 16（即默认值） 。 反例： HashMap 需要放置 1024 个元素， 由于没有设置容量初始大小，随着元素不断增加，容量 7 次被迫扩大， resize 需要重建 hash 表，严重影响性能。 【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。 说明： keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 JDK8，使用 Map.foreach 方法。 正例： values()返回的是 V 值集合，是一个 list 集合对象； keySet()返回的是 K 值集合，是一个 Set 集合对象； entrySet()返回的是 K-V 值组合集合。 【推荐】高度注意 Map 类集合 K/V 能不能存储 null 值的情况，如下表格： 集合类 | Key | Value | Super | 说明—-|—–|——-|——-|—Hashtable | 不允许为null | 不允许为null | Dictionary | 线程安全ConcurrentHashMap | 不允许为null | 不允许为null | AbstractMap | 锁分段技术（ JDK8:CAS）TreeMap | 不允许为null | 允许为null | AbstractMap | 线程不安全HashMap | 允许为null | 允许为null | AbstractMap | 线程不安全 反例： 由于 HashMap 的干扰，很多人认为 ConcurrentHashMap 是可以置入 null 值，而事实上，存储 null 值时会抛出 NPE 异常。 参考(2) 【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。 说明： 有序性是指遍历的结果是按某种比较规则依次排列的。 稳定性指集合每次遍历的元素次序是一定的。 如： ArrayList 是 order/unsort； HashMap 是 unorder/unsort； TreeSet 是order/sort。 【参考】利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的contains 方法进行遍历、对比、 去重操作。]]></content>
      <categories>
        <category>阿里java规约</category>
      </categories>
      <tags>
        <tag>阿里java规约</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里java规约(一)-编程规约(4)-OOP规约.md]]></title>
    <url>%2F2018%2F02%2F09%2F%E9%98%BF%E9%87%8Cjava%E8%A7%84%E7%BA%A6%2F%E9%98%BF%E9%87%8Cjava%E8%A7%84%E7%BA%A6(%E4%B8%80)-%E7%BC%96%E7%A8%8B%E8%A7%84%E7%BA%A6(4)-OOP%E8%A7%84%E7%BA%A6%2F</url>
    <content type="text"><![CDATA[OOP规约(20)强制(12) 【强制】使用类的静态变量或静态方法，直接用类名访问。 【强制】所有的覆写方法，必须加@Override 注解。 说明： getObject()与 get0bject()的问题。一个是字母的 O，一个是数字的 0，加@Override可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。 【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。 说明： 可变参数必须放置在参数列表的最后。 （ 提倡同学们尽量不用可变参数编程） 正例： public User getUsers(String type, Integer… ids) {…} 【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名， 避免对接口调用方产生影响。接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。 【强制】不能使用过时的类或方法。 说明： java.net.URLDecoder 中的方法 decode(String encodeStr) 这个方法已经过时，应该使用双参数 decode(String source, String encode)。接口提供方既然明确是过时接口，那么有义务同时提供新的接口； 作为调用方来说，有义务去考证过时方法的新实现是什么。 【强制】 Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。 正例： “test”.equals(object); 反例： object.equals(“test”); 说明： 推荐使用 java.util.Objects#equals（ JDK7 引入的工具类） 【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。 说明： 对于 Integer var = ? 在-128 至 127 范围内的赋值， Integer 对象是在IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断。 关于基本数据类型与包装数据类型的使用标准如下： 1） 【强制】 所有的 POJO 类属性必须使用包装数据类型。 2） 【强制】 RPC 方法的返回值和参数必须使用包装数据类型。 3） 【推荐】 所有的局部变量使用基本数据类型。 说明： POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE 问题，或者入库检查，都由使用者来保证。 正例： 数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。 反例： 比如显示成交总额涨跌情况，即正负 x%， x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线。所以包装数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出。 【强制】定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值。 反例： POJO 类的 gmtCreate 默认值为 new Date();但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。 【强制】序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败； 如果完全不兼容升级，避免反序化混乱，那么请修改 serialVersionUID 值。 说明： 注意 serialVersionUID 不一致会抛出序列化运行时异常。 【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。 【强制】 POJO 类必须写 toString 方法。使用 IDE 中的工具： source&gt; generate toString时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString。 说明： 在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排查问题。 推荐(8) 【推荐】使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛 IndexOutOfBoundsException 的风险。 说明： 1234String str = "a,b,c,,";String[] ary = str.split(",");// 预期大于 3，结果是 3System.out.println(ary.length); 【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读，此条规则优先于第 15 条规则。 【推荐】类内方法定义的顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter/setter 方法。 说明： 公有方法是类的调用者和维护者最关心的方法，首屏展示最好； 保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法； 而私有方法外部一般不需要特别关心，是一个黑盒实现； 因为承载的信息价值较低，所有 Service 和 DAO 的 getter/setter 方法放在类体最后。 【推荐】 setter 方法中，参数名称与类成员变量名称一致， this.成员名 = 参数名。在getter/setter 方法中， 不要增加业务逻辑，增加排查问题的难度。 反例： 1234567public Integer getData() &#123; if (condition) &#123; return this.data + 100; &#125; else &#123; return this.data - 100; &#125;&#125; 【推荐】循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。 说明： 反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行append 操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费。 反例： 1234String str = "start";for (int i = 0; i &lt; 100; i++) &#123; str = str + "hello";&#125; 【推荐】 final 可以声明类、成员变量、方法、以及本地变量，下列情况使用 final 关键字： 1） 不允许被继承的类，如： String 类。 2） 不允许修改引用的域对象，如： POJO 类的域变量。 3） 不允许被重写的方法，如： POJO 类的 setter 方法。 4） 不允许运行过程中重新赋值的局部变量。 5） 避免上下文重复使用一个变量，使用 final 描述可以强制重新定义一个变量，方便更好地进行重构。 【推荐】慎用 Object 的 clone 方法来拷贝对象。 说明： 对象的 clone 方法默认是浅拷贝，若想实现深拷贝需要重写 clone 方法实现属性对象的拷贝。 【推荐】类成员与方法访问控制从严： 1） 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。 2） 工具类不允许有 public 或 default 构造方法。 3） 类非 static 成员变量并且与子类共享，必须是 protected。 4） 类非 static 成员变量并且仅在本类使用，必须是 private。 5） 类 static 成员变量如果仅在本类使用，必须是 private。 6） 若是 static 成员变量，必须考虑是否为 final。 7） 类成员方法只供类内部调用，必须是 private。 8） 类成员方法只对继承类公开，那么限制为 protected。 说明： 任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。 思考：如果是一个 private 的方法，想删除就删除，可是一个 public 的 service 成员方法或成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大， 无限制的到处跑，那么你会担心的。]]></content>
      <categories>
        <category>阿里java规约</category>
      </categories>
      <tags>
        <tag>阿里java规约</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里java规约(一)-编程规约(3)-代码格式.md]]></title>
    <url>%2F2018%2F02%2F09%2F%E9%98%BF%E9%87%8Cjava%E8%A7%84%E7%BA%A6%2F%E9%98%BF%E9%87%8Cjava%E8%A7%84%E7%BA%A6(%E4%B8%80)-%E7%BC%96%E7%A8%8B%E8%A7%84%E7%BA%A6(3)-%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[代码格式(11)强制(9) 【强制】大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行； 如果是非空代码块则： 1） 左大括号前不换行。 2） 左大括号后换行。 3） 右大括号前换行。 4） 右大括号后还有 else 等代码则不换行； 表示终止的右大括号后必须换行。 【强制】 左小括号和字符之间不出现空格； 同样，右小括号和字符之间也不出现空格。详见第 5 条下方正例提示。 反例： if (空格 a == b 空格) 【强制】 if/for/while/switch/do 等保留字与括号之间都必须加空格。 【强制】任何二目、 三目运算符的左右两边都需要加一个空格。 说明： 运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号等。 【强制】 采用 4 个空格缩进，禁止使用 tab 字符。 说明： 如果使用 tab 缩进，必须设置 1 个 tab 为 4 个空格。 IDEA 设置 tab 为 4 个空格时， 请勿勾选 Use tab character；而在 eclipse 中，必须勾选 insert spaces for tabs。 正例： （ 涉及 1-5 点） 123456789101112131415161718public static void main(String[] args) &#123; // 缩进 4 个空格 String say = "hello"; // 运算符的左右必须有一个空格 int flag = 0; // 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号， 0 与右括号不需要空格 if (flag == 0) &#123; System.out.println(say); &#125; // 左大括号前加空格且不换行；左大括号后换行 if (flag == 1) &#123; System.out.println("world"); // 右大括号前换行，右大括号后有 else，不用换行 &#125; else &#123; System.out.println("ok"); // 在右大括号后直接结束，则必须换行 &#125;&#125; 【强制】注释的双斜线与注释内容之间有且仅有一个空格。 正例： 12// 这是示例注释，请注意在双斜线之后有一个空格String ygb = new String(); 【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则： 1） 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。 2） 运算符与下文一起换行。 3） 方法调用的点符号与下文一起换行。 4） 方法调用时，多个参数， 需要换行时， 在逗号后进行。 5） 在括号前不要换行，见反例。 正例： 123456StringBuffer sb = new StringBuffer();// 超过 120 个字符的情况下，换行缩进 4 个空格， 点号和方法名称一起换行sb.append("zi").append("xin")... .append("huang")... .append("huang")... .append("huang"); 反例： 1234567StringBuffer sb = new StringBuffer();// 超过 120 个字符的情况下，不要在括号前换行sb.append("zi").append("xin")...append("huang");// 参数很多的方法调用可能超过 120 个字符， 不要在逗号前换行method(args1, args2, args3, ..., argsX); 【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。 正例： 下例中实参的”a”,后边必须要有一个空格。 1method("a", "b", "c"); 【强制】 IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不要使用 Windows 格式。 推荐(2) 【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。 正例： 1234int a = 3;long b = 4L;float c = 5F;StringBuffer sb = new StringBuffer(); 说明： 增加 sb 这个变量，如果需要对齐，则给 a、 b、 c 都要增加几个空格，在变量比较多的情况下，是非常累赘的事情。 【推荐】 不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性。 说明： 没有必要插入多个空行进行隔开。]]></content>
      <categories>
        <category>阿里java规约</category>
      </categories>
      <tags>
        <tag>阿里java规约</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里java规约(一)-编程规约(2)-常量定义.md]]></title>
    <url>%2F2018%2F02%2F09%2F%E9%98%BF%E9%87%8Cjava%E8%A7%84%E7%BA%A6%2F%E9%98%BF%E9%87%8Cjava%E8%A7%84%E7%BA%A6(%E4%B8%80)-%E7%BC%96%E7%A8%8B%E8%A7%84%E7%BA%A6(2)-%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[常量定义(5)强制(2) 【强制】不允许任何魔法值（ 即未经预先定义的常量） 直接出现在代码中。 【强制】 long 或者 Long 初始赋值时， 使用大写的 L，不能是小写的 l，小写容易跟数字 1 混淆，造成误解。 说明： Long a = 2l; 写的是数字的 21，还是 Long 型的 2? 推荐(3) 【推荐】不要使用一个常量类维护所有常量， 按常量功能进行归类，分开维护。 说明： 大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。 正例： 缓存相关常量放在类 CacheConsts 下； 系统配置相关常量放在类 ConfigConsts 下。 【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。 1） 跨应用共享常量：放置在二方库中，通常是 client.jar 中的 constant 目录下。 2） 应用内共享常量：放置在一方库中，通常是子模块中的 constant 目录下。 反例： 易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示“是”的变量： 类 A 中： public static final String YES = &quot;yes&quot;; 类 B 中： public static final String YES = &quot;y&quot;; A.YES.equals(B.YES)，预期是 true，但实际返回为 false，导致线上问题。 3） 子工程内部共享常量：即在当前子工程的 constant 目录下。 4） 包内共享常量：即在当前包下单独的 constant 目录下。 5） 类内共享常量：直接在类内部 private static final 定义。 【推荐】如果变量值仅在一个固定范围内变化用 enum 类型来定义。 说明： 如果存在名称之外的延伸属性使用 enum 类型，下面正例中的数字就是延伸信息，表示一年中的第几个季节。 正例：1234567public enum SeasonEnum &#123; SPRING(1), SUMMER(2), AUTUMN(3), WINTER(4); int seq; SeasonEnum(int seq)&#123; this.seq = seq; &#125;&#125;]]></content>
      <categories>
        <category>阿里java规约</category>
      </categories>
      <tags>
        <tag>阿里java规约</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里java规约(一)-编程规约(1)-命名风格.md]]></title>
    <url>%2F2018%2F02%2F09%2F%E9%98%BF%E9%87%8Cjava%E8%A7%84%E7%BA%A6%2F%E9%98%BF%E9%87%8Cjava%E8%A7%84%E7%BA%A6(%E4%B8%80)-%E7%BC%96%E7%A8%8B%E8%A7%84%E7%BA%A6(1)-%E5%91%BD%E5%90%8D%E9%A3%8E%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[命名风格(16)强制(10) 【强制】不以下划线或美元符号做开头结尾 【强制】禁止使用拼音与英文混合,禁止使用中文,纯拼音也尽量避免 正例： alibaba / taobao / youku / hangzhou 等国际通用的名称， 可视同英文。 【强制】类名使用 UpperCamelCase 风格，但以下情形例外： DO / BO / DTO / VO / AO / PO 等。 正例： MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion 反例： macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion 【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。 【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。 【强制】抽象类命名使用 Abstract 或 Base 开头； 异常类命名使用 Exception 结尾； 测试类命名以它要测试的类名开始，以 Test 结尾。 【强制】类型与中括号紧挨相连来定义数组。 正例： 定义整形数组 int[] arrayDemo; 反例： 在 main 参数中，使用 String args[]来定义。 【强制】POJO 类中布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列化错误。 【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。 正例： 应用工具类包名为 com.alibaba.ai.util、类名为 MessageUtils（ 此规则参考 spring 的框架结构） 【强制】杜绝完全不规范的缩写， 避免望文不知义。 反例： AbstractClass“缩写” 命名成 AbsClass； condition“ 缩写” 命名成 condi，此类随意缩写严重降低了代码的可阅读性。 推荐(4) 【推荐】为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达其意。 正例： 从远程仓库拉取代码的类命名为 PullCodeFromRemoteRepository。 反例： 变量 int a; 的随意命名方式。 【推荐】如果模块、 接口、类、方法使用了设计模式，在命名时体现出具体模式。 说明： 将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。 正例： public class OrderFactory; public class LoginProxy; public class ResourceObserver; 【推荐】接口类中的方法和属性不要加任何修饰符号（ public 也不要加） ，保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。 正例： 接口方法签名 void f(); 接口基础常量 String COMPANY = &quot;alibaba&quot;; 反例： 接口方法定义 public abstract void f(); 说明： JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默认实现。 接口和实现类的命名有两套规则： 【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别。 正例： CacheServiceImpl 实现 CacheService 接口。 【推荐】 如果是形容能力的接口名称，取对应的形容词为接口名 （ 通常是–able 的形式）。 正例： AbstractTranslator 实现 Translatable。 参考(2) 【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。 说明： 枚举其实就是特殊的常量类，且构造方法被默认强制是私有。 正例： 枚举名字为 ProcessStatusEnum 的成员名称： SUCCESS / UNKNOWN_REASON。 【参考】各层命名规约： Service/DAO 层方法命名规约 获取单个对象的方法用 get 作前缀。 获取多个对象的方法用 list 作前缀。 获取统计值的方法用 count 作前缀。 插入的方法用 save/insert 作前缀。 删除的方法用 remove/delete 作前缀。 修改的方法用 update 作前缀。 领域模型命名规约 数据对象： xxxDO， xxx 即为数据表名。 数据传输对象： xxxDTO， xxx 为业务领域相关的名称。 展示对象： xxxVO， xxx 一般为网页名称。 POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。]]></content>
      <categories>
        <category>阿里java规约</category>
      </categories>
      <tags>
        <tag>阿里java规约</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux修改时间]]></title>
    <url>%2F2018%2F01%2F24%2F%E6%9D%82%E8%AE%B0%2Flinux%E4%BF%AE%E6%94%B9%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[linux修改时间 修改时区 cp /usr/share/zoneinfo/UTC /etc/localtime 12345[root@localhost ~]# cp /usr/share/zoneinfo/UTC /etc/localtime cp：是否覆盖“/etc/localtime”? y [root@localhost ~]# date 2012年 11月 02日 星期五 00:07:30 UTC修改为中国的东八区 配置新的时间 1234# vi /etc/sysconfig/clockZONE=&quot;Asia/Shanghai&quot;UTC=falseARC=false 安装ntp 1yum install -y ntp 设置时间同步 1ntpdate 210.72.145.44 1. 其他命令1.1. 设置时间1date -s 18:40:00 参考链接 Linux服务器同步网络时间]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 程序down 问题排查]]></title>
    <url>%2F2018%2F01%2F24%2F%E6%9D%82%E8%AE%B0%2Flinux%20%E7%A8%8B%E5%BA%8Fdown%20%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[1. linux系统有自我保护机制如果分配的内存用完了,会杀掉进程.可以查看日志1/var/log/messages 然后通过进程ID 进行查询 ,或者 oom-killer 来查询 1.1. 内存不够可以配置虚拟内存,解决内存高峰时内存不够的问题. 2. 线程挂掉用jstack分析线程栈可以使用 jstack 查看进程信息 3. 其他命令3.1. lsof -n (学习)]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js心跳请求]]></title>
    <url>%2F2018%2F01%2F24%2F%E6%9D%82%E8%AE%B0%2Fjs%E5%BF%83%E8%B7%B3%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[示例代码,mark一下var timer = setInterval (function(){},time)clearInterval(timer) 1234567891011121314151617181920212223var timer;timer = setInterval(function()&#123; Common.ajax.execute(&#123; 'url': Common.url.getBaseURL() + '/flow/get-trusteeship.do', 'data': &#123; "programId": $("#programId").val(), &#125;, 'success': function (data) &#123; if (data.result == 'success' &amp;&amp; data.trusteeship) &#123; if(data.trusteeship.status == 3)&#123; clearInterval(timer); EmayPagination.action.skipToCurrentPage($('#trusteeshipListQueryPaginationContainer'), $('#trusteeshipListQueryPaginationContainer .pagination-node.active').attr('data-current-page-number')); Trusteeship.dom.setStep(3); &#125; &#125; &#125;, 'error': function () &#123; Messager.action.error('操作异常。'); &#125; &#125;);&#125;,5000);]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下安装opencv-java]]></title>
    <url>%2F2018%2F01%2F24%2F%E6%9D%82%E8%AE%B0%2Flinux%E4%B8%8B%E5%AE%89%E8%A3%85opencv-java%2F</url>
    <content type="text"><![CDATA[linux下安装opencv java 1. 说明在正式环境安装的时候安装opencv时候一直编译失败，缺少文件，后来下载了310版本的opencv，可以用了线上环境linux centos6.5 2. linux版本centos7 3. 安装jdk4. 安装ant4.1. 下载ant官网下载http://ant.apache.org/bindownload.cgi1apache-ant-1.9.9-bin.tar.gz 4.2. 解压 重命名12unzip apache-ant-1.9.9-bin.tar.gzmv apache-ant-1.9.9 ant 4.3. 配置环境变量1234vim /etc/profile 在文件后加入 export ANT_HOME=/usr/local/ant export PATH=$ANT_HOME/bin:$PATH 4.4. 刷新环境变量1source /etc/profile 5. 安装OpenCV5.1. 安装OpenCV依赖库1yum install -y build-essential gcc gcc-c++ cmake git pkgconfig gtk+-devel gtk2-devel python python-pip python-devel 5.2. 下载可以到官网下载 选择对应版本，我这里是3.3.1https://opencv.org/releases.html 5.3. 解压先解压,解压后进入目录,创建build目录,进入build目录,准备预编译123unzip opencv-3.3.1.zipcd opencv-3.3.1 mkdir build &amp;&amp; cd build/ 5.4. 预编译通过cmake命令预先编译一次,编译完成后查看输出结果, 在be built```里包含java这一项就表示预编译成功12```cmake -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=OFF -DBUILD_EXAMPLES=OFF -DBUILD_TESTS=OFF -DBUILD_PERF_TESTS=OFF -DCMAKE_INSTALL_PREFIX=/usr/local .. 可能会卡在1-- IPPICV: Download: ippicv_2017u3_lnx_intel64_general_20170822.tgz 这个文件比较大,下载时间长一点,不要着急 5.5. 编译cmake完成后，在build目录直接输入make进行编译，如果服务器CPU核数比较多，可以在make后加入-j8 使用8个线程同时进行编译，加快编译速度。1make -j2 关于下面这个异常，我编译的时候并没有出现，记录一下，备用。 编译过程可能出现异常，提示： /usr/include/jasper/jas_math.h:117:22: error: ‘SIZE_MAX’ was not declared in this scope 出现这个异常，不要慌，可以通过修改/usr/include/jasper/jas_math.h 文件源码解决。在/usr/include/jasper/jas_math.h 的头部#include 的下面添加:123#if ! defined SIZE_MAX #define SIZE_MAX (4294967295U) #endif 然后重新编译就可以了。如果不行，请删除build目录下的内容，重新预编译、编译就应该没问题了 5.6. 安装编译完成，就可以进行安装，安装过程是生成opencv对应的库文件，我这里是java项目需要用到，所以也会顺便生成java相关的库文件1make install 命令执行完成，会在结果中看到/usr/local/share/OpenCV/java/目录生成了两个java相关的依赖库文件 opencv-331.jar 和 libopencv_java331.so ， 当然，每个人的环境不同，可能目录也不同，具体看日志输出就行了。1234[root@opencv java]# ll /usr/local/share/OpenCV/java总用量 72012-rwxr-xr-x 1 root root 73320721 11月 8 14:05 libopencv_java331.so-rw-r--r-- 1 root root 414381 11月 8 10:03 opencv-331.jar 6. 参考链接 opencv官方文档 Installation in Linux CentOS6 - Linux下安装OpenCV]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat+idea远程调试]]></title>
    <url>%2F2018%2F01%2F24%2F%E6%9D%82%E8%AE%B0%2Ftomcat%2Bidea%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[1. 测试的web项目12345678910111213141516171819package com.signalfire.servlet;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by jk on 2017/12/12. */public class HelloServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println("111111111111111111"); resp.getWriter().write("hello baby"); resp.getWriter().flush(); &#125;&#125; 1234567891011121314&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;my&lt;/servlet-name&gt; &lt;servlet-class&gt;com.signalfire.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;my&lt;/servlet-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 2. tomcat 打war包部署到tomcat中 使用默认配置启动tomcat调试1[root@mytest bin]# ./catalina.sh jpda start 默认情况下，远程调试的默认端口为8000，可以通过JPDA_ADDRESS进行配置，指定自定义的端口，另外，还有两个可以配置的参数 JPDA_TRANSPORT：即调试器和虚拟机之间数据的传输方式，默认值是dt_socket JPDA_SUSPEND：即JVM启动后是否立即挂起，默认是n可以在catalina.sh中进行配置：123JPDA_TRANSPORT=dt_socket JPDA_ADDRESS=5005 JPAD_SUSPEND=n 3. idea配置远程调试3.1. 配置 3.2. debug启动 3.3. 结果 4. 调试java程序在远程服务器上java启动参赛要加上调试的参数：“-Xdebug -Xrunjdwp:transport=dt_socket,address=2345,server=y,suspend=n”]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务框架与实战-笔记03-开始使用SpringCloud实战微服务]]></title>
    <url>%2F2018%2F01%2F21%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%AE%9E%E6%88%98-%E7%AC%94%E8%AE%B003-%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8SpringCloud%E5%AE%9E%E6%88%98%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[配套代码 http://www.broadview.com.cn/book/4774 可以去勘误等 1-11 章配套代码：https://github.com/itmuch/spring-cloud-docker-microservice-book-code 12-14 章配套代码：https://github.com/itmuch/spring-cloud-docker-microservice-book-code-docker 1. 实战前提1.1. 技术储备 语言基础：java或scala、Groovy spring boot ： 项目管理和构建工具：maven gradle （可以相互转换）1.2. 工具及软件版本 JKD：官方建议1.8，也可以用1.7 springboot： 书中使用1.4.5.RELEASE springCloud：Camden SR4 IDE：Spring Tool suite 3.8.3 基于eclipse的IDE ，idea maven：3.3.9 （3.3.x运行在JDK1.8以上）降低学习成本的重要方法之一:少踩坑2. 服务提供者、服务消费者描述微服务之间的调用关系服务提供者：被调用方服务消费者：调用方3. 编写服务提供者Spring Data JPA作为持久层框架，H2作为数据库3.1. 编写项目自己下载代码看吧，microservice-simple-provider-user3.1.1. pom.xmlspring-boot-starter-web：springMVC支持spring-boot-starter-data-jpa：Spring Data JPA支持123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itmuch.cloud&lt;/groupId&gt; &lt;artifactId&gt;microservice-simple-provider-user&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!-- 引入spring boot的依赖 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.3.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 引入spring cloud的依赖 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Camden.SR4&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!-- 添加spring-boot的maven插件 --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 3.1.2. classpath下schema.sql 建表语句12drop table user if exists;create table user (id bigint generated by default as identity, username varchar(40), name varchar(20), age int(3), balance decimal(10,2), primary key (id)); 3.1.3. classpath下data.sql123insert into user (id, username, name, age, balance) values (1, 'account1', '张三', 20, 100.00);insert into user (id, username, name, age, balance) values (2, 'account2', '李四', 28, 180.00);insert into user (id, username, name, age, balance) values (3, 'account3', '王五', 32, 280.00); 3.1.4. 用户实体类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.itmuch.cloud.study.entity;import java.math.BigDecimal;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;@Entitypublic class User &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; @Column private String username; @Column private String name; @Column private Integer age; @Column private BigDecimal balance; public Long getId() &#123; return this.id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getUsername() &#123; return this.username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getName() &#123; return this.name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return this.age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public BigDecimal getBalance() &#123; return this.balance; &#125; public void setBalance(BigDecimal balance) &#123; this.balance = balance; &#125;&#125; 3.2. DAO12345678910package com.itmuch.cloud.study.repository;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.stereotype.Repository;import com.itmuch.cloud.study.entity.User;@Repositorypublic interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;&#125; 3.3. controller@GetMapping Spring4.3新注解。组合注解，等价 @RequestMapping(method=RequestMethod.GET)还有@PostMapping、@PutMapping、@DeleteMapping、@PatchMapping123456789101112131415161718192021package com.itmuch.cloud.study.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import com.itmuch.cloud.study.entity.User;import com.itmuch.cloud.study.repository.UserRepository;@RestControllerpublic class UserController &#123; @Autowired private UserRepository userRepository; @GetMapping("/&#123;id&#125;") public User findById(@PathVariable Long id) &#123; User findOne = this.userRepository.findOne(id); return findOne; &#125;&#125; 3.4. 启动类@SpringBootApplication 声明是一个Spring boot项目 组合注解，整合了@Configuration、@EnableAutoConfiguration、@ComponentScan 并开启了SpringBoot组件扫描和自动配置功能1234567891011package com.itmuch.cloud.study;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class ProviderUserApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProviderUserApplication.class, args); &#125;&#125; 3.5. 配置文件 application.ymlSpringCloud、SpringBoot支持properties或者yml格式文件作为配置文件yml文件格式：YAML（Yet Another Markup Language）编写的文件格式。YAML和properties格式文件可以互相转换。yml文件有严格的缩进123456789101112131415161718192021222324252627server: port: 8000spring: jpa: generate-ddl: false show-sql: true hibernate: ddl-auto: none datasource: # 指定数据源 platform: h2 # 指定数据源类型 schema: classpath:schema.sql # 指定h2数据库的建表脚本 data: classpath:data.sql # 指定h2数据库的数据脚本logging: # 配置日志级别，让hibernate打印出执行的SQL level: root: INFO org.hibernate: INFO org.hibernate.type.descriptor.sql.BasicBinder: TRACE org.hibernate.type.descriptor.sql.BasicExtractor: TRACE ## INFOinfo: app: name: @project.artifactId@ encoding: @project.build.sourceEncoding@ java: source: @java.version@ target: @java.version@ 测试：http://localhost:8000/1]]></content>
      <categories>
        <category>微服务学习</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务框架与实战-总体概览]]></title>
    <url>%2F2018%2F01%2F21%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%AE%9E%E6%88%98-%E6%80%BB%E4%BD%93%E6%A6%82%E8%A7%88%2F</url>
    <content type="text"><![CDATA[这本书整体的看了一遍，具体细节还没有实践。先做个骨架，用的时候再丰富下。书中按照下面的顺序进行整合。 table th:first-of-type { width: 15px; } table th:nth-of-type(2) { width: 20%; } table th:nth-of-type(3) { width: 30%; } 章 组件 功能 描述 3 spring-boot 基础业务开发 spring-boot-actuator 提供很多监控端点 4 Eureka 服务的注册与发现 集成于spring-cloud-netflix 是Netflix开源的服务发现组件基于REST的服务相似组件： Zookeeper，Consul 5 Ribbon 客户端测负载均衡 Netflix发布的负载均衡器有助于控制HTTP和TCP客户端的行为。 Feign 实现声明式REST调用 Netflix开发的声明式、模板化的HTTP客户端。 Hystrix 服务容错处理 Turbine 聚合Hystrix监控数据的工具 将所有相关 /hystrix.stream 端点的数据聚合到一个聚合的/turbine.stream中让集群的监控更加方便 RabbitMQ 消息中间件 解决网络故障问题（例如微服务与Turbine网络不通） 8 Zuul 构建微服务网关 Netflix开源的微服务网关可以和Eureka、Ribbon、Hystrix等组件配合使用核心是一系列的过滤器 Sidecar 整合非JVM微服务 9 spring-cloud-Config 统一管理微服务配置 10 spring-cloud-sleuth 微服务跟踪 分布式跟踪的解决方案 ELK 日志分析系统 Zipkin Twitter开源的分布式跟踪系统 可与Sleuth配合使用收集系统的时序数据追踪微服务框架的系统延时等问题提供友好的界面，帮助分析追踪数据。 12 Docker 开源容器引擎有助于更快地交付应用 可将应用程序和基础设施层隔离能将基础设置当做程序一样进行管理可更快地打包、测试以及部署应用程序缩短从编写到部署运行代码的周期 14 Docker Compose 编排微服务 用于定义和运行多容器Docker应用程序的工具前身是Fig非常适合用在开发、测试、构建CI工作流等场景 雪崩效应： 我们常把 “基础服务故障” 导致 “级联故障” 的现象成为雪崩效应。 描述的是提供者不可用导致消费者不可用，并将不可用逐渐放大的过程。]]></content>
      <categories>
        <category>微服务学习</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务框架与实战-笔记02-微服务开发框架-SpringCloud]]></title>
    <url>%2F2018%2F01%2F09%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%AE%9E%E6%88%98-%E7%AC%94%E8%AE%B002-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6-SpringCloud%2F</url>
    <content type="text"><![CDATA[1. Spring Cloud 简介 在SpringBoot基础上构建的，用于快速构建分布式系统的通用模式工具集。 程序适合在Docker或者PaaS上部署。 所以又叫云原生应用（Cloud Native Application）。 云原生（CloudNative）可简单理解为面向云环境的软件架构。2. Spring Cloud 特点 约定优于配置 适用于各种环境 隐藏了组件的复杂性，并提供声明式、无xml的配置方式 开箱即用、快速启动 轻量级组件 组件丰富，功能齐全。如 配置管理，服务发现，断路器，微服务网关等 选型中立、丰富。例如：支持使用Eureka、Zookeeper、Consul实现服务发现。 灵活。组成部分解耦，可按需挑选技术选型。3. 版本Spring项目一般以下面这种方式命名，但SpringCloud并没有使用这种方式。可以略过。主版本号.次版本号.增量版本号.里程碑版本号例如：4.3.5.RELEASE 主版本号：项目重大重构 次版本号：新特性的添加和变化 增量版本号：一般表示BUG修复 里程碑版本号：某个版本号的里程碑3.1. 版本简介命名方式：英文单词SRX（x为数字）英文单词：release trainSR：service release bug修复 Dalston SR5 表示Dalston 第5次bug修复版本 https://github.com/spring-cloud/spring-cloud-release/releases 版本发布 3.2. 子项目一览 Component Camden.SR7 Dalston.SR4 Edgware.RELEASE Finchley.M4 Finchley.BUILD-SNAPSHOT spring-cloud-aws 1.1.4.RELEASE 1.2.1.RELEASE 1.2.2.RELEASE 2.0.0.M2 2.0.0.BUILD-SNAPSHOT spring-cloud-bus 1.2.2.RELEASE 1.3.1.RELEASE 1.3.2.RELEASE 2.0.0.M3 2.0.0.BUILD-SNAPSHOT spring-cloud-cli 1.2.4.RELEASE 1.3.4.RELEASE 1.4.0.RELEASE 2.0.0.M1 2.0.0.BUILD-SNAPSHOT spring-cloud-commons 1.1.9.RELEASE 1.2.4.RELEASE 1.3.0.RELEASE 2.0.0.M4 2.0.0.BUILD-SNAPSHOT spring-cloud-contract 1.0.5.RELEASE 1.1.4.RELEASE 1.2.0.RELEASE 2.0.0.M4 2.0.0.BUILD-SNAPSHOT spring-cloud-config 1.2.3.RELEASE 1.3.3.RELEASE 1.4.0.RELEASE 2.0.0.M4 2.0.0.BUILD-SNAPSHOT spring-cloud-netflix 1.2.7.RELEASE 1.3.5.RELEASE 1.4.0.RELEASE 2.0.0.M4 2.0.0.BUILD-SNAPSHOT spring-cloud-security 1.1.4.RELEASE 1.2.1.RELEASE 1.2.1.RELEASE 2.0.0.M1 2.0.0.BUILD-SNAPSHOT spring-cloud-cloudfoundry 1.0.1.RELEASE 1.1.0.RELEASE 1.1.0.RELEASE 2.0.0.M1 2.0.0.BUILD-SNAPSHOT spring-cloud-consul 1.1.4.RELEASE 1.2.1.RELEASE 1.3.0.RELEASE 2.0.0.M3 2.0.0.BUILD-SNAPSHOT spring-cloud-sleuth 1.1.3.RELEASE 1.2.5.RELEASE 1.3.0.RELEASE 2.0.0.M4 2.0.0.BUILD-SNAPSHOT spring-cloud-stream Brooklyn.SR3 Chelsea.SR2 Ditmars.RELEASE Elmhurst.M3 Elmhurst.BUILD-SNAPSHOT spring-cloud-zookeeper 1.0.4.RELEASE 1.1.2.RELEASE 1.2.0.RELEASE 2.0.0.M3 2.0.0.BUILD-SNAPSHOT spring-boot 1.4.5.RELEASE 1.5.4.RELEASE 1.5.8.RELEASE 2.0.0.M6 2.0.0.BUILD-SNAPSHOT spring-cloud-task 1.0.3.RELEASE 1.1.2.RELEASE 1.2.2.RELEASE 2.0.0.M2 2.0.0.RELEASE spring-cloud-vault 1.0.2.RELEASE 1.1.0.RELEASE 2.0.0.M4 2.0.0.BUILD-SNAPSHOT spring-cloud-gateway 1.0.0.RELEASE 2.0.0.M4 2.0.0.BUILD-SNAPSHOT 3.3. spring cloud / spring boot 版本兼容性 Finchley使用Spring Boot 2.0.x构建和运行，并且不希望与Spring Boot 1.5.x一起使用。 Dalston和Edgware发行版建立在Spring Boot 1.5.x之上，并且不希望与Spring Boot 2.0.x一起使用。 Camden发行版基于Spring Boot 1.4.x，但也使用1.5.x进行测试。 http://projects.spring.io/spring-cloud/ 更具体的额可以看这里]]></content>
      <categories>
        <category>微服务学习</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用多个git账户]]></title>
    <url>%2F2018%2F01%2F07%2F%E6%9D%82%E8%AE%B0%2F%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AAgit%E8%B4%A6%E6%88%B7%2F</url>
    <content type="text"><![CDATA[1. 生成两个SSH key为了举例方便，这里使用“one”和“two”两个账户。下同。123$ ssh-keygen -t rsa -C &quot;one@gmail.com&quot;$ ssh-keygen -t rsa -C &quot;two@gmail.com&quot; 不要一路回车，分别在第一个对话的时候输入重命名（id_rsa_one和id_rsa_two），这样会生成两份，包含私钥和公钥的4个文件。1234id_rsa_oneid_rsa_one.pubid_rsa_twoid_rsa_two.pub 2. 添加私钥 打开ssh-agent 如果你是github官方的bash： 1$ ssh-agent -s 如果你是其它，比如msysgit： 1$ eval $(ssh-agent -s) 添加私钥 123ssh-agent bash //不执行这个会报没有权限$ ssh-add ~/.ssh/id_rsa_one$ ssh-add ~/.ssh/id_rsa_two 3. 创建config文件在.ssh下创建config 123456789101112# one(one@gmail.com) Host one.github.com //自定义的映射HostName github.com //git仓库对应的地址PreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa_one //对应为文件User one //对应的用户名# two(two@ gmail.com)Host two.github.comHostName github.com PreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa_twoUser two 4. 部署SSH key在github上添加对应的ssh key 5. clone项目方法 $ git clone git@one.github.com: one的用户名/learngit.git 注意是自定义的域名 和用户名（git的用户名）$ git clone git@two.github.com: two的用户名/learngit.git 6. 其他（与上面没有关联）6.1. git的三种环境变量 系统变量。 存放在git的安装目录下：%Git%\etc\gitconfig。 若使用 git config 时用 –system 选项，读写的就是这个文件： $ git config –system core.symlinks 系统变量对所有用户都适用。 用户变量。 存放在用户目录下。例如windows xp存放在：C:\Documents and Settings\$USER.gitconfig。 若使用 git config 时用 –global 选项，读写的就是这个文件： $ git config –global user.name 用户变量只适用于该用户 本地项目变量 当前项目的 git 目录中的配置文件（也就是工作目录中的 .git/config 文件）。 若使用git config 时用 –local 选项，读写的就是这个文件： $ git config –local remote.origin.url 本地变量只对当前项目有效。 6.2. 查找顺序本地 》 用户 》系统 6.3. 其他config命令12345$ git config --list 查看所有环境变量$ git config --system --list 查看系统环境变量$ git config --global --list 查看用户环境变量$ git config --local --list 查看本地环境变量$ git config --[system/global/local] [varname] [yourname] 编辑环境变量]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务框架与实战-笔记01-概述]]></title>
    <url>%2F2018%2F01%2F05%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%AE%9E%E6%88%98-%E7%AC%94%E8%AE%B001-%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[1. 单体应用架构存在的问题 复杂性高 包含模块多 模块边界模糊 依赖关系不清 代码质量残次不齐等等 技术债务 部署频率低 功能变更或缺陷修复都要重新部署整个应用。 全量部署 耗时长。影响范围大、风险高。 可靠性差 一个bug可能会导致整个系统的崩溃 扩展能力受限 只能整体扩展，无法根据业务模块进行伸缩。 阻碍技术创新 一般使用统一的技术平台或方案解决所有问题。例如一个使用struts2的100万行代码的单体应用，如果想换成springMVC，成本是非常高的。 2. 微服务简介并没有严格的定义，将一个单一应用程序开发为一组小型服务的方法。构建的是分布式系统。 2.1. 特性 每个服务运行在自己的进程中 一系列服务共同构建起整个项目 服务针对独立业务，只关注某个特定功能 服务间通信采用轻量级通信机制（如http资源api） 可以使用不同的语言，不同的存储 全自动部署机制 3. 有点 易于开发维护 单个服务启动快 局部修改易部署 技术栈不受限 按需伸缩 4. 挑战 运维要求高 需要保证几十个甚至上百个服务的正常运行与写作 分布式固有的复杂性 接口调整成本搞 重复劳动 重复功能不足以分解为一个微服务，可以封装为公共组件，但是多语言就不一定行得通 5. 设计原则 单一职责原则 服务自治原则 治具备独立的业务能力、依赖与运行环境。 轻量级通信机制 体量轻 跨语言 跨平台 常用的有REST AMQP STOMP MQTT 微服务力度 康威定律：设计系统的组织，其产生的设计等同于组织之内、组织之间的沟通结构。看看下面的图片（来源于互联网，侵删），再想想Apple的产品、微软的产品设计，就能形象生动的理解这句话。 用通俗的说法就是：组织形式等同系统设计。 6. 如何实现微服务架构6.1. 技术选型从开发和运行平台两个维度考虑： 开发框架 spring cloud dubbo dropwizard armada 运行平台 并不绑定运行平台 PCServer 阿里云 aws Docker7. 架构图]]></content>
      <categories>
        <category>微服务学习</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[aws-vpn]]></title>
    <url>%2F2018%2F01%2F03%2F%E6%9D%82%E8%AE%B0%2Faws-vpn%2F</url>
    <content type="text"><![CDATA[1. aws服务器的创建及vpn的安装https://www.jianshu.com/p/b0d460efca4e 2. 配置 IPsec/L2TP VPN 客户端https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/docs/clients-zh.md#windows 2.1. 注册表修改https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/docs/clients-zh.md#windows-错误-809 windows10注册表修改,然后需要重启才能连上vpn1REG ADD HKLM\SYSTEM\CurrentControlSet\Services\PolicyAgent /v AssumeUDPEncapsulationContextOnSendRule /t REG_DWORD /d 0x2 /f]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vpn</tag>
        <tag>aws</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据0501-轻量级RPC框架开发]]></title>
    <url>%2F2018%2F01%2F01%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2F%E5%A4%A7%E6%95%B0%E6%8D%AE0501-%E8%BD%BB%E9%87%8F%E7%BA%A7RPC%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[1、掌握RPC原理2、掌握nio操作3、掌握netty简单的api4、掌握自定义RPC框架 1. RPC原理1.1. 什么是RPCRPC（Remote Procedure Call Protocol）——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。 1.2. RPC原理 运行时,一次客户机对服务器的RPC调用,其内部操作大致有如下十步： 调用客户端句柄；执行传送参数 调用本地系统内核发送网络消息 消息传送到远程主机 服务器句柄得到消息并取得参数 执行远程过程 执行的过程将结果返回服务器句柄 服务器句柄返回结果，调用远程系统内核 消息传回本地主机 客户句柄由内核接收消息 客户接收句柄返回的数据 2. NIOnio 是New IO 的简称，在jdk1.4 里提供的新api 。Sun 官方标榜的特性如下： 为所有的原始类型提供(Buffer)缓存支持。字符集编码解码解决方案。 Channel ：一个新的原始I/O 抽象。 支持锁和内存映射文件的文件访问接口。 提供多路(non-bloking) 非阻塞式的高伸缩性网络I/O 。 2.1. socket nio原理2.1.1. 传统的I/O使用传统的I/O程序读取文件内容, 并写入到另一个文件(或Socket), 如下程序:12File.read(fileDesc, buf, len);Socket.send(socket, buf, len); 会有较大的性能开销, 主要表现在一下两方面: 上下文切换(context switch), 此处有4次用户态和内核态的切换 Buffer内存开销, 一个是应用程序buffer, 另一个是系统读取buffer以及socket buffer 其运行示意图如下 先将文件内容从磁盘中拷贝到操作系统buffer 再从操作系统buffer拷贝到程序应用buffer 从程序buffer拷贝到socket buffer 从socket buffer拷贝到协议引擎. 2.2. NIONIO技术省去了将操作系统的read buffer拷贝到程序的buffer, 以及从程序buffer拷贝到socket buffer的步骤, 直接将 read buffer 拷贝到 socket buffer. java 的 FileChannel.transferTo() 方法就是这样的实现, 这个实现是依赖于操作系统底层的sendFile()实现的.1publicvoid transferTo(long position, long count, WritableByteChannel target); 他的底层调用的是系统调用sendFile()方法1sendfile(int out_fd, int in_fd, off_t *offset, size_t count); 如下图 参考帖子：http://blog.csdn.net/dd864140130/article/details/50299687 3. 轻量级RPC开发3.1. 轻量级RPC框架需求分析及原理分析 3.2. 大概流程 3.3. 工程目录 rpc-sample-server 用户服务端 业务实现类 rpc-sample-common 用户公用包 包含了业务接口 rpc-sample-app 用户客户端 调用业务接口 rpc-server 框架 服务包 rpc-registry 框架 注册和发现 zk用的包 rpc-common 框架 公共包 request response 加密 解密 序列化等公用类 rpc-client 框架 客户包3.4. 框架rpc-server 主要利用反射将接收到的request进行解析、执行、返回结果。rpc-client 主要使用动态代理将接口的调用 封装进request进行请求，然后返回结果。]]></content>
      <categories>
        <category>大数据学习笔记</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>rpc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北京冬天哪里好玩]]></title>
    <url>%2F2017%2F12%2F22%2F%E5%85%B6%E4%BB%96%2F%E5%8C%97%E4%BA%AC%E5%86%AC%E5%A4%A9%E5%93%AA%E9%87%8C%E5%A5%BD%E7%8E%A9%2F</url>
    <content type="text"><![CDATA[发愁冬天去哪玩？北京这10个地方好玩还不冷！周末约起~转来的 1. 古北水镇过暖冬冬日的水镇一改盛夏的浓艳，鳞次栉比的房屋，青石板的老街，悠长的胡同……让水镇更添几分宁静、祥和。这时候来古北逛逛古镇，看看夜景，泡泡温泉，真是从头到脚的舒心！ 1.1. 门票信息：180.00元（体验价80.00元）1.2. 自驾路线：上了京承高速，一直前行，路上会有古北水镇的标示牌，下了高速，基本就到停车场。从京承高速收费站到古北水镇大约有120公里的路程。tips：四季皆宜。 春季碧波荡漾，水镇宛若一幅江南水墨画；夏季纳凉避暑，戏水游乐；秋季银杏落叶和古朴的建筑情景交融，摄影取材的好去处；冬季皑皑白雪的覆盖下，河面冻结，嬉雪赏冰雕…… 2. 首都博物馆欲了解一个地方，必去当地的博物馆！首都博物馆是咱们“老北京的博物馆”，从北京的历史文化，生活民俗，风土人文，全面的介绍北京的兴衰变迁。是深度了解北京的好地方。 2.1. 门票：持有效证件免费参观 地址：西城区复兴门外大街16号2.2. 路线 地铁：乘坐地铁1号线木樨地站下 公交：26、80、45、114、308、特19、937、843、844、840、845路白云路站 3. 呀路古热带植物园北京呀路古热带植物园位于北京市大兴区长子营镇，是北京市最大的热带植物园，占地面积600亩。虽然外面寒风烈烈，但这里确是温暖如春！景区收集了热带果树、热带饮料植物、热带观赏植物、热带药用植物、棕榈植物、热带濒危植物、热带珍奇植物和蔬菜作物等，热带亚热带物种达上千余种景区内主要景点有勐巴拉娜西热带植物馆、土司堡民族展览馆和恐龙馆、孔雀馆等。景区内森林繁茂，蔓藤缠绕，不失为冬季的好去处。 3.1. 门票：60元3.2. 乘车线路： 1、市区游客可乘坐976路、826路、926路公交车。 2、大兴黄村地区的游客可以坐940路公交车朱庄站下车前行200米即到。 4. 北京天文馆4.1. 简介北京天文馆是中国第一座天文馆，馆内有直径23.5米象征天穹的天象厅，中间安装精致的国产大型天象仪，可表演日、月、星辰、流星彗星、日食以及月食等天象。北京天文馆包含A、B两馆，共4个科普剧场。 4.1.1. A馆 门厅正中 ： 反映地球自转的傅科摆 西侧展厅 ： 陈列天文知识展览 东侧演讲厅 ： 经常举行学术交流和普及天文科学知识报告。 庭院中有两座天文台，其中一座装有口径13厘米的望远镜，可通过它观看月亮、行星、星云、星团，白天观测太阳黑子。 4.2. 门票：4.2.1. 元/人4.2.2. 天象厅：45元/人4.2.3. 宇宙剧场：30元/人4.2.4. D剧场、4D剧场：45元/人4.3. 乘车线路：乘7、15、19、27、65、102、103、105、107、111、319、332、334、347、360、362、534、601、632、634、714、732、808、814、运通104、运通105、运通106、特4路动物园站下;地铁4号线动物园站D出口。 5. 南宫温泉水世界南宫温泉坐落在4A级南宫旅游景区内，这里可是“中国地热第一村”！也是北京最大的一块地热田！温泉水都来自2980米深得地热井，每天出水量为2700吨，温度69—72℃~整座水世界呈热带雨林的风情，里面种满了热带树木、植物，还有数十种汤泉药浴；儿童戏水乐园，漂流、戏水滑道…. 5.1. 路线 地址:北京市丰台区王佐镇南宫南路9号 自驾：京港澳高速’南宫王佐19A’出口出向北第二个红绿灯右转200米路北 公交：乘458路,459路,951路,836路直达王佐镇政府站下车 6. 顺景温泉日式汤屋、溶洞、水世界…在帝都，温泉我只服这一家！顺景温泉总占地13万平米，是吉尼斯认证的“全球最大室内温泉”！这里的温泉水非常珍贵！活性矿物质远远高于理疗热矿水浓度标准室内外温泉池相互衔接，清池湖泊、小桥流水…充满着神秘色彩，给人以原始丛林的生态之美。还有千奇百怪、突兀嶙峋的溶洞。置身于顺景的溶洞景观中，仿入梦境。满眼都是数万年的各异钟乳石、石笋，一切都分外神秘与美丽！ 6.1. 人均：240元左右/人6.2. 路线 地址：朝阳区北四环东路2号 电话：010-84420088 010-85696688 乘车路线：847路、131路、401路、404路、641路公交在四元桥西站下车，步行至酒店。 7. X先生密室X先生密室是一家大型真人密室逃脱游戏场所，致力于打造最全面的融合紧张刺激，需要玩家在房间中寻找线索，通过合作找出所有线索，交流和思考解开全部谜题，一步一步的走近最终答案，最终逃出密室。绝对属于高科技范儿的密室逃脱，连实景岩洞、水池皮划都能在神秘屋里体验到。解开谜题的钥匙可能藏在任何物件里，有可能你身上穿的衣服也能帮你逃出牢笼。 7.1. 人均消费：140元7.2. 路线 地址：朝阳区 工体北路13号世茂广场·工三 2层(工体北门对面)。 营业时间：10:00—2:20(22:30之后来店需提前电话咨询) 电话：4008598298。 8. 北京自然博物馆如果不知道该如何打发时间，就来位于天桥南侧的北京自然博物馆吧~ 里面有各种动、植物标本、恐龙骨架、人体知识、小小水族馆….在这里，时间仿佛是静止的，不知孩子，大人也能玩的不亦乐乎~有恐龙的化石骨骼，有恐龙的仿真模型，那些模型十分逼真，甚至有的还可以发出恐龙的叫声~还有小小的海洋世界，没有太平洋富国海底世界那么大，只是一个不大的走廊，但是你也可以看到很多的海洋动植物~ 如果小朋友来这里，真的能疯玩一整天！ 8.1. 门票：门票免费，至少需提前一天预约，不能预约当日参观门票8.2. 路线 地址：北京市东城区天桥南大街126号 公交7路, 17路, 20路, 35路, 36路, 69路, 71路, 72路天桥西门下车 地铁：地铁7号线 珠市口站 9. 地质博物馆中国地质博物馆是中国成立最早的地质学博物馆，创建于1916年，以其典藏系统、成果丰硕、陈列精美称雄于亚洲同类博物馆，并且在世界范围内享有盛誉。中国地质博物馆收藏地质标本20余万件，涵盖地学各个领域。其中有蜚声海内外的巨型山东龙、中华龙鸟等恐龙系列化石，北京人、元谋人、山顶洞人等著名古人类化石等。 9.1. 门票：30元9.2. 乘车线路：市内交通：乘13、22、38、47、68、101、102、103、105、109、124、409、603、709、726、806、808、812、814、823、826、846、850路公共汽车西四站下 10. 世界花卉大观园世界花卉大观园位于北京南四环辅路北侧，京开公路东侧，全园41.8公顷，是北京市四环以内最大的植物园。世界花卉大观园景观由七大温室和十五个花园广场组成。各温室内的植物千奇百怪、花锦簇。热带植物馆中有数百年的佛肚树、重阳木、古榕树等乔木1800余种；沙生植物温室有上百种仙人掌、仙人球；精品花卉厅有生动风趣的植物生肖园、精品盆景园等等。 10.1. 门票：60元10.2. 乘车线路：4号线公益西桥站下车换乘646路到世界花卉大观园站下车。]]></content>
      <categories>
        <category>玩</category>
      </categories>
      <tags>
        <tag>北京</tag>
        <tag>游玩</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录有北京游玩的链接]]></title>
    <url>%2F2017%2F12%2F22%2F%E5%85%B6%E4%BB%96%2F%E8%AE%B0%E5%BD%95%E6%9C%89%E5%8C%97%E4%BA%AC%E6%B8%B8%E7%8E%A9%E7%9A%84%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[发愁冬天去哪玩？北京这10个地方好玩还不冷！周末约起~]]></content>
      <categories>
        <category>玩</category>
      </categories>
      <tags>
        <tag>北京</tag>
        <tag>游玩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据0406-javaJVM技术]]></title>
    <url>%2F2017%2F12%2F05%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2F%E5%A4%A7%E6%95%B0%E6%8D%AE0406-javaJVM%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[1. 监控工具的使用1.1. jconsole可以分析jvm的内存使用情况和线程等信息。 1.2. 启动方式JDK/bin 目录下 jconsole.exe将自动搜索出本机运行的所有JVM进程，不需要用户使用jps来查询了，双击其中一个进程即可开始监控。也可以“远程连接服务器，进行远程虚拟机的监控。” 1.3. jvisualvm提供了和jconsole的功能类似，提供了一大堆的插件。插件中，Visual GC（可视化GC）还是比较好用的，可视化GC可以看到内存的具体使用情况。 2. java内存模型2.1. 内存模型图解Java虚拟机在执行Java程序的过程中，会把它所管理的内存划分为若干个不同的数据区。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有的区域则依赖用户线程的启动和结束而建立和销毁，我们可以将这些区域统称为Java运行时数据区域。如下图是一个内存模型的关系图（详情见图：内存划分.png）： Java虚拟机运行时数据区域被分为五个区域：堆(Heap)、栈(Stack)、本地方法栈(Native Stack)、方法区(Method Area)、程序计数器(Program Count Register)。 2.2. 堆（Heap）对于大多数应用来说，Java Heap是Java虚拟机管理的内存的最大一块，这块区域随着虚拟机的启动而创建。在实际的运用中，我们创建的对象和数组就是存放在堆里面。如果你听说线程安全的问题，就会很明确的知道Java Heap是一块共享的区域，操作共享区域的成员就有了锁和同步。与Java Heap相关的还有Java的垃圾回收机制（GC）,Java Heap是垃圾回收器管理的主要区域。程序猿所熟悉的新生代、老生代、永久代的概念就是在堆里面，现在大多数的GC基本都采用了分代收集算法。如果再细致一点，Java Heap还有Eden空间，From Survivor空间,To Survivor空间等。Java Heap可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。 2.3. 栈（Stack）相对于Java Heap来讲，Java Stack是线程私有的，她的生命周期与线程相同。Java Stack描述的是Java方法执行时的内存模型，每个方法执行时都会创建一个栈帧（Stack Frame）用语存储局部变量表、操作数栈、动态链接、方法出口等信息。从下图从可以看到，每个线程在执行一个方法时，都意味着有一个栈帧在当前线程对应的栈帧中入栈和出栈。 图中可以看到每一个栈帧中都有局部变量表。局部变量表存放了编译期间的各种基本数据类型，对象引用等信息。 2.4. 本地方法栈（Native Stack）本地方法栈（Native Stack）与Java虚拟机站（Java Stack）所发挥的作用非常相似，他们之间的区别在于虚拟机栈为虚拟机栈执行java方法（也就是字节码）服务，而本地方法栈则为使用到Native方法服务。 2.5. 方法区（Method Area）方法区（Method Area）与堆（Java Heap）一样，是各个线程共享的内存区域，它用于存储虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是她却有一个别名叫做非堆（Non-Heap）。分析下Java虚拟机规范，之所以把方法区描述为堆的一个逻辑部分，应该觉得她们都是存储数据的角度出发的。一个存储对象数据（堆），一个存储静态信息(方法区)。 2.6. 总结2.6.1. 线程私有的数据区域有：Java虚拟机栈（Java Stack）本地方法栈（Native Stack） 2.6.2. 线程共有的数据区域有：堆（Java Heap）方法区 3. JVM参数列表java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0-Xmx3550m：最大堆内存为3550M。-Xms3550m：初始堆内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。-Xmn2g：设置年轻代大小为2G。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。-Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在 3000~5000左右。-XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6-XX:MaxPermSize=16m:设置持久代大小为16m。-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直 接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象 再年轻代的存活时间，增加在年轻代即被回收的概论。 收集器设置-XX:+UseSerialGC:设置串行收集器-XX:+UseParallelGC:设置并行收集器-XX:+UseParalledlOldGC:设置并行年老代收集器-XX:+UseConcMarkSweepGC:设置并发收集器垃圾回收统计信息-XX:+PrintGC-XX:+PrintGCDetails-XX:+PrintGCTimeStamps-Xloggc:filename并行收集器设置-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)并发收集器设置-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。 4. jvm案例演示4.1. 内存Jconsole的内存标签相当于可视化的jstat命令，用于监视收集器管理的虚拟机内存（java堆和永久代）的变化趋势。我们通过下面的一段代码体验一下它的监视功能。运行时设置的虚拟机参数为：-Xms100m -Xmx100m -XX:+UseSerialGC，这段代码的作用是以64kb/50毫秒的速度往java堆内存中填充数据。12345678910111213141516171819public class TestMemory &#123; static class OOMObject &#123; public byte[] placeholder = new byte[64 * 1024]; &#125; public static void fillHeap(int num) throws Exception &#123; ArrayList&lt;OOMObject&gt; list = new ArrayList&lt;OOMObject&gt;(); for (int i = 0; i &lt; num; i++) &#123; Thread.sleep(50); list.add(new OOMObject()); &#125; System.gc(); &#125; public static void main(String[] args) throws Exception &#123; fillHeap(1000); Thread.sleep(500000); &#125;&#125; 从图中可以看出，运行轨迹成曲线增长，循环1000次后，虽然整个新生代Eden和Survivor区都基本上被清空了，但是老年代仍然保持峰值状态，这说明，填充的数据在GC后仍然存活，因为list的作用域没有结束。如果把System.gc();移到fillHeap(1000);后，就可以全部回收掉。 4.2. 线程jconsole线程标签相当于可视化了jstack命令，遇到线程停顿时，可以使用这个也签进行监控分析。线程长时间停顿的主要原因有：等待外部资源（数据库连接等），死循环、锁等待。下面的代码将演示这几种情况：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package cn.java.jvm;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class TestThread &#123; /** * 死循环演示 * * @param args */ public static void createBusyThread() &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("createBusyThread"); while (true) ; &#125; &#125;, "testBusyThread"); thread.start(); &#125; /** * 线程锁等待 * * @param args */ public static void createLockThread(final Object lock) &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("createLockThread"); synchronized (lock) &#123; try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;, "testLockThread"); thread.start(); &#125; public static void main(String[] args) throws Exception &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); br.readLine(); createBusyThread(); br.readLine(); Object object = new Object(); createLockThread(object); &#125;&#125; main线程：追踪到需要键盘录入testBusyThread线程：线程阻塞在18行的while（true），直到线程切换，很耗性能testLockThread线程：出于waitting状态，等待notify 死锁：123456789101112131415161718192021222324252627package cn.java.jvm;public class TestDeadThread implements Runnable &#123; int a, b; public TestDeadThread(int a, int b) &#123; this.a = a; this.b = b; &#125; @Override public void run() &#123; System.out.println("createDeadThread"); synchronized (Integer.valueOf(a)) &#123; synchronized (Integer.valueOf(b)) &#123; System.out.println(a + b); &#125; &#125; &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 100; i++) &#123; new Thread(new TestDeadThread(1, 2)).start(); new Thread(new TestDeadThread(2, 1)).start(); &#125; &#125;&#125; 点击检查死锁，会出现死锁的详情。 thread-5的锁被thread-10持有，相反亦是，造成死锁。]]></content>
      <categories>
        <category>大数据学习笔记</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据0405-java-socket]]></title>
    <url>%2F2017%2F12%2F03%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2F%E5%A4%A7%E6%95%B0%E6%8D%AE0405-java-socket%2F</url>
    <content type="text"><![CDATA[直接上代码吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package cn.itcast.bigdata.socket;import java.net.InetSocketAddress;import java.net.ServerSocket;import java.net.Socket;public class ServiceServer &#123; public static void main(String[] args) throws Exception &#123; // 创建一个serversocket，绑定到本机的8899端口上 ServerSocket server = new ServerSocket(); server.bind(new InetSocketAddress("localhost", 8899)); // 接受客户端的连接请求;accept是一个阻塞方法，会一直等待，到有客户端请求连接才返回 while (true) &#123; Socket socket = server.accept(); new Thread(new ServiceServerTask(socket)).start(); &#125; &#125;&#125;======================package cn.itcast.bigdata.socket;import java.io.BufferedReader;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.io.PrintWriter;import java.net.Socket;public class ServiceClient &#123; public static void main(String[] args) throws Exception &#123; /*ServiceIterface service = ProxyUtils.getProxy(ServiceIterface.class,"methodA",hostname,port); Result = service.methodA(parameters);*/ // 向服务器发出请求建立连接 Socket socket = new Socket("localhost", 8899); // 从socket中获取输入输出流 InputStream inputStream = socket.getInputStream(); OutputStream outputStream = socket.getOutputStream(); PrintWriter pw = new PrintWriter(outputStream); pw.println("hello"); pw.flush(); BufferedReader br = new BufferedReader(new InputStreamReader(inputStream)); String result = br.readLine(); System.out.println(result); inputStream.close(); outputStream.close(); socket.close(); &#125;&#125;======================package cn.itcast.bigdata.socket;public class GetDataServiceImpl &#123; public String getData(String param)&#123; return "ok-"+param; &#125;&#125;=======================package cn.itcast.bigdata.socket;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.io.PrintWriter;import java.net.Socket;public class ServiceServerTask implements Runnable&#123; Socket socket ; InputStream in=null; OutputStream out = null; public ServiceServerTask(Socket socket) &#123; this.socket = socket; &#125; //业务逻辑：跟客户端进行数据交互 @Override public void run() &#123; try &#123; //从socket连接中获取到与client之间的网络通信输入输出流 in = socket.getInputStream(); out = socket.getOutputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(in)); //从网络通信输入流中读取客户端发送过来的数据 //注意：socketinputstream的读数据的方法都是阻塞的 String param = br.readLine(); /** * 作业： * 将以下业务调用逻辑写成更加通用的：可以根据客户端发过来的调用类名、调用方法名、调用该参数来灵活调用 * * 《反射》 * */ GetDataServiceImpl getDataServiceImpl = new GetDataServiceImpl(); String result = getDataServiceImpl.getData(param); //将调用结果写到sokect的输出流中，以发送给客户端 PrintWriter pw = new PrintWriter(out); pw.println(result); pw.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; try &#123; in.close(); out.close(); socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>大数据学习笔记</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>java</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据0404-java动态代理]]></title>
    <url>%2F2017%2F12%2F03%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2F%E5%A4%A7%E6%95%B0%E6%8D%AE0404-java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. 动态代理在之前的代码调用阶段，我们用action调用service的方法实现业务即可。由于之前在service中实现的业务可能不能够满足当先客户的要求，需要我们重新修改service中的方法，但是service的方法不只在我们这个模块使用，在其他模块也在调用，其他模块调用的时候，现有的service方法已经能够满足业务需求，所以我们不能只为了我们的业务而修改service，导致其他模块授影响。那怎么办呢？可以通过动态代理的方式，扩展我们的service中的方法实现，使得在原有的方法中增加更多的业务，而不是实际修改service中的方法，这种实现技术就叫做动态代理。动态代理：在不修改原业务的基础上，基于原业务方法，进行重新的扩展，实现新的业务。 1.1. 例如下面的例子： 旧业务买家调用action，购买衣服，衣服在数据库的标价为50元，购买流程就是简单的调用。 新业务在原先的价格上可以使用优惠券，但是这个功能在以前没有实现过，我们通过代理类，代理了原先的接口方法，在这个方法的基础上，修改了返回值。 代理实现流程： 书写代理类和代理方法，在代理方法中实现代理Proxy.newProxyInstance 代理中需要的参数分别为：被代理的类的类加载器soneObjectclass.getClassLoader()，被代理类的所有实现接口new Class[] { Interface.class }，句柄方法new InvocationHandler() 在句柄方法中复写invoke方法，invoke方法的输入有3个参数Object proxy（代理类对象）, Method method（被代理类的方法）,Object[] args（被代理类方法的传入参数），在这个方法中，我们可以定制化的开发新的业务。 获取代理类，强转成被代理的接口 最后，我们可以像没被代理一样，调用接口的认可方法，方法被调用后，方法名和参数列表将被传入代理类的invoke方法中，进行新业务的逻辑流程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677原业务接口IBoss=================================/** * 这是一个业务的接口，这个接口中的业务就是返回衣服的价格 * @author wilson * */public interface IBoss &#123;//接口 int yifu(String size);&#125;原业务实现类====================================public class Boss implements IBoss&#123; public int yifu(String size)&#123; System.err.println("天猫小强旗舰店，老板给客户发快递----衣服型号："+size); //这件衣服的价钱，从数据库读取 return 50; &#125; public void kuzi()&#123; System.err.println("天猫小强旗舰店，老板给客户发快递----裤子"); &#125;&#125;原业务调用====================================public class SaleAction &#123; @Test public void saleByBossSelf() throws Exception &#123; IBoss boss = new Boss(); System.out.println("老板自营！"); int money = boss.yifu("xxl"); System.out.println("衣服成交价：" + money); &#125;&#125;代理类========================================import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class ProxyBoss &#123; /** * 对接口方法进行代理 */ @SuppressWarnings("unchecked") public static &lt;T&gt; T getProxy(final int discountCoupon, final Class&lt;?&gt; interfaceClass, final Class&lt;?&gt; implementsClass) throws Exception &#123; return (T) Proxy.newProxyInstance(interfaceClass.getClassLoader(), new Class[] &#123; interfaceClass &#125;, new InvocationHandler() &#123; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Integer returnValue = (Integer) method.invoke( implementsClass.newInstance(), args);// 调用原始对象以后返回的值 return returnValue - discountCoupon; &#125; &#125;); &#125;&#125;新业务调用=======================================import org.junit.Test;import cn.itcast_05_proxy.proxyclass.ProxyBoss;import cn.itcast_05_proxy.service.IBoss;import cn.itcast_05_proxy.service.impl.Boss;/** * 什么是动态代理？ 简单的写一个模板接口，剩下的个性化工作，好给动态代理来完成！ */public class ProxySaleAction &#123; /** *使用代理，在这个代理中，只代理了Boss的yifu方法 *定制化业务，可以改变原接口的参数、返回值等 */ @Test public void saleByProxy() throws Exception &#123; IBoss boss = ProxyBoss.getProxy(10,IBoss.class,Boss.class);// 将代理的方法实例化成接口 //IBoss boss = new Boss();// 将代理的方法实例化成接口 System.out.println("代理经营！"); int money = boss.yifu("xxl");// 调用接口的方法，实际上调用方式没有变 System.out.println("衣服成交价：" + money); &#125;&#125;]]></content>
      <categories>
        <category>大数据学习笔记</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>java</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据0403-java反射]]></title>
    <url>%2F2017%2F12%2F03%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2F%E5%A4%A7%E6%95%B0%E6%8D%AE0403-java%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[通过反射的方式可以获取class对象中的属性、方法、构造函数等:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package cn.itcast_04_reflect;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.List;import org.junit.Before;import org.junit.Test;public class MyReflect &#123; public String className = null; @SuppressWarnings("rawtypes") public Class personClass = null; /** * 反射Person类 * @throws Exception */ @Before public void init() throws Exception &#123; className = "cn.itcast_04_reflect.Person"; personClass = Class.forName(className); &#125; /** *获取某个class文件对象 */ @Test public void getClassName() throws Exception &#123; System.out.println(personClass); &#125; /** *获取某个class文件对象的另一种方式 */ @Test public void getClassName2() throws Exception &#123; System.out.println(Person.class); &#125; /** *创建一个class文件表示的实例对象，底层会调用空参数的构造方法 */ @Test public void getNewInstance() throws Exception &#123; System.out.println(personClass.newInstance()); &#125; /** *获取非私有的构造函数 */ @SuppressWarnings(&#123; "rawtypes", "unchecked" &#125;) @Test public void getPublicConstructor() throws Exception &#123; Constructor constructor = personClass.getConstructor(Long.class,String.class); Person person = (Person)constructor.newInstance(100L,"zhangsan"); System.out.println(person.getId()); System.out.println(person.getName()); &#125; /** *获得私有的构造函数 */ @SuppressWarnings(&#123; "rawtypes", "unchecked" &#125;) @Test public void getPrivateConstructor() throws Exception &#123; Constructor con = personClass.getDeclaredConstructor(String.class); con.setAccessible(true);//强制取消Java的权限检测 Person person2 = (Person)con.newInstance("zhangsan"); System.out.println("**"+person2.getName()); &#125; /** *访问非私有的成员变量 */ @SuppressWarnings(&#123; "rawtypes", "unchecked" &#125;) @Test public void getNotPrivateField() throws Exception &#123; Constructor constructor = personClass.getConstructor(Long.class,String.class); Object obj = constructor.newInstance(100L,"zhangsan"); Field field = personClass.getField("name"); field.set(obj, "lisi"); System.out.println(field.get(obj)); &#125; /** *访问私有的成员变量 */ @SuppressWarnings(&#123; "rawtypes", "unchecked" &#125;) @Test public void getPrivateField() throws Exception &#123; Constructor constructor = personClass.getConstructor(Long.class); Object obj = constructor.newInstance(100L); Field field2 = personClass.getDeclaredField("id"); field2.setAccessible(true);//强制取消Java的权限检测 field2.set(obj,10000L); System.out.println(field2.get(obj)); &#125; /** *获取非私有的成员函数 */ @SuppressWarnings(&#123; "unchecked" &#125;) @Test public void getNotPrivateMethod() throws Exception &#123; System.out.println(personClass.getMethod("toString")); Object obj = personClass.newInstance();//获取空参的构造函数 Method toStringMethod = personClass.getMethod("toString"); Object object = toStringMethod.invoke(obj); System.out.println(object); &#125; /** *获取私有的成员函数 */ @SuppressWarnings("unchecked") @Test public void getPrivateMethod() throws Exception &#123; Object obj = personClass.newInstance();//获取空参的构造函数 Method method = personClass.getDeclaredMethod("getSomeThing"); method.setAccessible(true); Object value = method.invoke(obj); System.out.println(value); &#125; /** * */ @Test public void otherMethod() throws Exception &#123; //当前加载这个class文件的那个类加载器对象 System.out.println(personClass.getClassLoader()); //获取某个类实现的所有接口 Class[] interfaces = personClass.getInterfaces(); for (Class class1 : interfaces) &#123; System.out.println(class1); &#125; //反射当前这个类的直接父类 System.out.println(personClass.getGenericSuperclass()); /** * getResourceAsStream这个方法可以获取到一个输入流，这个输入流会关联到name所表示的那个文件上。 */ //path 不以’/'开头时默认是从此类所在的包下取资源，以’/'开头则是从ClassPath根下获取。其只是通过path构造一个绝对路径，最终还是由ClassLoader获取资源。 System.out.println(personClass.getResourceAsStream("/log4j.properties")); System.out.println(personClass.getResourceAsStream("log4j.properties")); //判断当前的Class对象表示是否是数组 System.out.println(personClass.isArray()); System.out.println(new String[3].getClass().isArray()); //判断当前的Class对象表示是否是枚举类 System.out.println(personClass.isEnum()); System.out.println(Class.forName("cn.itcast_04_reflect.City").isEnum()); //判断当前的Class对象表示是否是接口 System.out.println(personClass.isInterface()); System.out.println(Class.forName("cn.itcast_04_reflect.TestInterface").isInterface()); &#125;&#125;]]></content>
      <categories>
        <category>大数据学习笔记</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据0402-JMS activeMQ]]></title>
    <url>%2F2017%2F12%2F03%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2F%E5%A4%A7%E6%95%B0%E6%8D%AE0402-JMS%20activeMQ%2F</url>
    <content type="text"><![CDATA[1. java JMS技术1.1. 什么是JMSJMS即Java消息服务（Java Message Service）应用程序接口是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。JMS是一种与厂商无关的 API，用来访问消息收发系统消息。它类似于JDBC(Java Database Connectivity)：这里，JDBC 是可以用来访问许多不同关系数据库的 API，而 JMS 则提供同样与厂商无关的访问方法，以访问消息收发服务。许多厂商都支持 JMS，包括 IBM 的 MQSeries、BEA的 Weblogic JMS service和 Progress 的 SonicMQ，这只是几个例子。 JMS 使您能够通过消息收发服务（有时称为消息中介程序或路由器）从一个 JMS 客户机向另一个 JMS客户机发送消息。消息是 JMS 中的一种类型对象，由两部分组成：报头和消息主体。报头由路由信息以及有关该消息的元数据组成。消息主体则携带着应用程序的数据或有效负载。根据有效负载的类型来划分，可以将消息分为几种类型，它们分别携带：简单文本(TextMessage)、可序列化的对象 (ObjectMessage)、属性集合 (MapMessage)、字节流 (BytesMessage)、原始值流 (StreamMessage)，还有无有效负载的消息 (Message)。 1.2. JMS规范1.2.1. 专业技术规范JMS（Java Messaging Service）是Java平台上有关面向消息中间件(MOM)的技术规范，它便于消息系统中的Java应用程序进行消息交换,并且通过提供标准的产生、发送、接收消息的接口简化企业应用的开发，翻译为Java消息服务。 1.2.2. 体系架构JMS由以下元素组成。 JMS提供者provider：连接面向消息中间件的，JMS接口的一个实现。提供者可以是Java平台的JMS实现，也可以是非Java平台的面向消息中间件的适配器。 JMS客户：生产或消费基于消息的Java的应用程序或对象。 JMS生产者：创建并发送消息的JMS客户。 JMS消费者：接收消息的JMS客户。 JMS消息：包括可以在JMS客户之间传递的数据的对象 JMS队列：一个容纳那些被发送的等待阅读的消息的区域。与队列名字所暗示的意思不同，消息的接受顺序并不一定要与消息的发送顺序相同。一旦一个消息被阅读，该消息将被从队列中移走。 JMS主题：一种支持发送消息给多个订阅者的机制。 1.2.3. Java消息服务应用程序结构支持两种模型1.2.3.1. 点对点或队列模型在点对点或队列模型下，一个生产者向一个特定的队列发布消息，一个消费者从该队列中读取消息。这里，生产者知道消费者的队列，并直接将消息发送到消费者的队列。这种模式被概括为： 只有一个消费者将获得消息 生产者不需要在接收者消费该消息期间处于运行状态，接收者也同样不需要在消息发送时处于运行状态。 每一个成功处理的消息都由接收者签收 1.2.3.2. 发布者/订阅者模型发布者/订阅者模型支持向一个特定的消息主题发布消息。0或多个订阅者可能对接收来自特定消息主题的消息感兴趣。在这种模型下，发布者和订阅者彼此不知道对方。这种模式好比是匿名公告板。这种模式被概括为： 多个消费者可以获得消息 在发布者和订阅者之间存在时间依赖性。发布者需要建立一个订阅（subscription），以便客户能够订阅。订阅者必须保持持续的活动状态以接收消息，除非订阅者建立了持久的订阅。在那种情况下，在订阅者未连接时发布的消息将在订阅者重新连接时重新发布。 2. 代码演示2.1. 下载ActiveMQ去官方网站下载：http://activemq.apache.org/ 2.2. 运行ActiveMQ解压缩apache-activemq-5.5.1-bin.zip，修改配置文件activeMQ.xml，将0.0.0.0修改为localhost123456&lt;transportConnectors&gt; &lt;transportConnector name="openwire" uri="tcp://localhost:61616"/&gt; &lt;transportConnector name="ssl" uri="ssl://localhost:61617"/&gt; &lt;transportConnector name="stomp" uri="stomp://localhost:61613"/&gt; &lt;transportConnector uri="http://localhost:8081"/&gt; &lt;transportConnector uri="udp://localhost:61618"/&gt; 然后双击apache-activemq-5.5.1\bin\activemq.bat运行ActiveMQ程序。启动ActiveMQ以后，登陆：http://localhost:8161/admin/，创建一个Queue，命名为FirstQueue。 3. 运行代码3.1. 常用的JMS实现要使用Java消息服务，你必须要有一个JMS提供者，管理会话和队列。既有开源的提供者也有专有的提供者。开源的提供者包括： Apache ActiveMQ JBoss 社区所研发的 HornetQ Joram Coridan的MantaRay The OpenJMS Group的OpenJMS 专有的提供者包括： BEA的BEA WebLogic Server JMS TIBCO Software的EMS GigaSpaces Technologies的GigaSpaces Softwired 2006的iBus IONA Technologies的IONA JMS SeeBeyond的IQManager（2005年8月被Sun Microsystems并购） webMethods的JMS+ - my-channels的Nirvana Sonic Software的SonicMQ SwiftMQ的SwiftMQ IBM的WebSphere MQ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201package cn.itcast_03_mq.topic;import javax.jms.Connection; import javax.jms.DeliveryMode; import javax.jms.Destination; import javax.jms.JMSException; import javax.jms.MessageProducer; import javax.jms.Session; import javax.jms.TextMessage; import org.apache.activemq.ActiveMQConnection; import org.apache.activemq.ActiveMQConnectionFactory; public class ProducerTool &#123; private String user = ActiveMQConnection.DEFAULT_USER; private String password = ActiveMQConnection.DEFAULT_PASSWORD; private String url = ActiveMQConnection.DEFAULT_BROKER_URL; private String subject = "mytopic"; private Destination destination = null; private Connection connection = null; private Session session = null; private MessageProducer producer = null; // 初始化 private void initialize() throws JMSException, Exception &#123; ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory( user, password, url); connection = connectionFactory.createConnection(); session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); destination = session.createTopic(subject); producer = session.createProducer(destination); producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT); &#125; // 发送消息 public void produceMessage(String message) throws JMSException, Exception &#123; initialize(); TextMessage msg = session.createTextMessage(message); connection.start(); System.out.println("Producer:-&gt;Sending message: " + message); producer.send(msg); System.out.println("Producer:-&gt;Message sent complete!"); &#125; // 关闭连接 public void close() throws JMSException &#123; System.out.println("Producer:-&gt;Closing connection"); if (producer != null) producer.close(); if (session != null) session.close(); if (connection != null) connection.close(); &#125; &#125; ----------------------------------------------------------package cn.itcast_03_mq.topic;import java.util.Random;import javax.jms.JMSException; public class ProducerTest &#123; /** * @param args */ public static void main(String[] args) throws JMSException, Exception &#123; ProducerTool producer = new ProducerTool(); Random random = new Random(); for(int i=0;i&lt;20;i++)&#123; Thread.sleep(random.nextInt(10)*1000); producer.produceMessage("Hello, world!--"+i); producer.close(); &#125; &#125; &#125; ----------------------------------------------------------package cn.itcast_03_mq.topic;import javax.jms.Connection; import javax.jms.Destination; import javax.jms.ExceptionListener;import javax.jms.JMSException; import javax.jms.MessageConsumer; import javax.jms.Session; import javax.jms.MessageListener; import javax.jms.Message; import javax.jms.TextMessage; import org.apache.activemq.ActiveMQConnection; import org.apache.activemq.ActiveMQConnectionFactory; public class ConsumerTool implements MessageListener,ExceptionListener &#123; private String user = ActiveMQConnection.DEFAULT_USER; private String password = ActiveMQConnection.DEFAULT_PASSWORD; private String url =ActiveMQConnection.DEFAULT_BROKER_URL; private String subject = "mytopic"; private Destination destination = null; private Connection connection = null; private Session session = null; private MessageConsumer consumer = null; public static Boolean isconnection=false; // 初始化 private void initialize() throws JMSException, Exception &#123; ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory( user, password, url); connection = connectionFactory.createConnection(); session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); destination = session.createTopic(subject); consumer = session.createConsumer(destination); &#125; // 消费消息 public void consumeMessage() throws JMSException, Exception &#123; initialize(); connection.start(); consumer.setMessageListener(this); connection.setExceptionListener(this); isconnection=true; System.out.println("Consumer:-&gt;Begin listening..."); // 开始监听 // Message message = consumer.receive(); &#125; // 关闭连接 public void close() throws JMSException &#123; System.out.println("Consumer:-&gt;Closing connection"); if (consumer != null) consumer.close(); if (session != null) session.close(); if (connection != null) connection.close(); &#125; // 消息处理函数 public void onMessage(Message message) &#123; try &#123; if (message instanceof TextMessage) &#123; TextMessage txtMsg = (TextMessage) message; String msg = txtMsg.getText(); System.out.println("Consumer:-&gt;Received: " + msg); &#125; else &#123; System.out.println("Consumer:-&gt;Received: " + message); &#125; &#125; catch (JMSException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public void onException(JMSException arg0) &#123; isconnection=false; &#125; &#125; ---------------------------------------------------------- package cn.itcast_03_mq.topic;import javax.jms.JMSException;public class ConsumerTest implements Runnable &#123; static Thread t1 = null; /** * @param args * @throws InterruptedException * @throws InterruptedException * @throws JMSException * @throws InterruptedException */ public static void main(String[] args) throws InterruptedException &#123; t1 = new Thread(new ConsumerTest()); t1.setDaemon(false); t1.start(); /** * 如果发生异常，则重启consumer */ /*while (true) &#123; System.out.println(t1.isAlive()); if (!t1.isAlive()) &#123; t1 = new Thread(new ConsumerTest()); t1.start(); System.out.println("重新启动"); &#125; Thread.sleep(5000); &#125;*/ // 延时500毫秒之后停止接受消息 // Thread.sleep(500); // consumer.close(); &#125; public void run() &#123; try &#123; ConsumerTool consumer = new ConsumerTool(); consumer.consumeMessage(); while (ConsumerTool.isconnection) &#123; &#125; &#125; catch (Exception e) &#123; &#125; &#125;&#125;]]></content>
      <categories>
        <category>大数据学习笔记</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>java</tag>
        <tag>JMS</tag>
        <tag>activeMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据0401-java多线程并发]]></title>
    <url>%2F2017%2F12%2F01%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2F%E5%A4%A7%E6%95%B0%E6%8D%AE0401-java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%2F</url>
    <content type="text"><![CDATA[内容包含 掌握多线程 掌握并发包下的队列 做个笔记，方便查看 1. java多线程增强1.1. 进程介绍不管是我们开发的应用程序，还是我们运行的其他的应用程序，都需要先把程序安装在本地的硬盘上。然后找到这个程序的启动文件，启动程序的时候，其实是电脑把当前的这个程序加载到内存中，在内存中需要给当前的程序分配一段独立的运行空间。这片空间就专门负责当前这个程序的运行。 不同的应用程序运行的过程中都需要在内存中分配自己独立的运行空间，彼此之间不会相互的影响。我们把每个独立应用程序在内存的独立空间称为当前应用程序运行的一个进程。 进程：它是内存中的一段独立的空间，可以负责当前应用程序的运行。当前这个进程负责调度当前程序中的所有运行细节。 1.2. 线程介绍在一个进程中，每个独立的功能都需要独立的去运行，这时又需要把当前这个进程划分成多个运行区域，每个独立的小区域（小单元）称为一个线程。 线程：它是位于进程中，负责当前进程中的某个具备独立运行资格的空间。进程是负责整个程序的运行，而线程是程序中具体的某个独立功能的运行。一个进程中至少应该有一个线程。 1.3. 多线程介绍多线程：在一个进程中，我们同时开启多个线程，让多个线程同时去完成某些任务（功能）。(比如后台服务系统，就可以用多个线程同时响应多个客户的请求)多线程的目的：提高程序的运行效率。 1.4. 多线程运行的原理cpu在线程中做时间片的切换。 其实真正电脑中的程序的运行不是同时在运行的。CPU负责程序的运行，而CPU在运行程序的过程中某个时刻点上，它其实只能运行一个程序。而不是多个程序。而CPU它可以在多个程序之间进行高速的切换。而切换频率和速度太快，导致人的肉眼看不到。每个程序就是进程， 而每个进程中会有多个线程，而CPU是在这些线程之间进行切换。了解了CPU对一个任务的执行过程，我们就必须知道，多线程可以提高程序的运行效率，但不能无限制的开线程。 1.5. 实现线程的两种方式1.5.1. 继承Thread的方式12345678910111213141516171819202122232425262728293031323334package cn.itcast_01_mythread.thread.testThread;import java.util.Random;public class MyThreadWithExtends extends Thread &#123; String flag; public MyThreadWithExtends(String flag)&#123; this.flag = flag; &#125; @Override public void run() &#123; String tname = Thread.currentThread().getName(); System.out.println(tname+"线程的run方法被调用……"); Random random = new Random(); for(int i=0;i&lt;20;i++)&#123; try &#123; Thread.sleep(random.nextInt(10)*100); System.out.println(tname+ "...."+ flag); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; Thread thread1 = new MyThreadWithExtends("a"); Thread thread2 = new MyThreadWithExtends("b"); thread1.start(); thread2.start(); /** * 如果是调用thread的run方法，则只是一个普通的方法调用，不会开启新的线程 */// thread1.run();// thread2.run(); &#125;&#125; 1.5.2. 声明实现 Runnable 接口的方式123456789101112131415161718192021222324252627282930package cn.itcast_01_mythread.thread.testThread;public class MyThreadWithImpliment implements Runnable &#123; int x; public MyThreadWithImpliment(int x) &#123; this.x = x; &#125; @Override public void run() &#123; String name = Thread.currentThread().getName(); System.out.println("线程" + name + "的run方法被调用……"); for (int i = 0; i &lt; 10; i++) &#123; System.out.println(x); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; Thread thread1 = new Thread(new MyThreadWithImpliment(1), "thread-1"); Thread thread2 = new Thread(new MyThreadWithImpliment(2), "thread-2"); thread1.start(); thread2.start(); // 注意调用run和调用start的区别,直接调用run，则都运行在main线程中// thread1.run();// thread2.run(); &#125;&#125; 2. java同步关键词解释2.1. synchronized2.1.1. 加同步格式：123synchronized( 需要一个任意的对象（锁） )&#123; 代码块中放操作共享数据的代码。&#125; 1234567891011121314151617181920212223242526272829303132package cn.itcast_01_mythread.thread.testThread;public class MySynchronized &#123; public static void main(String[] args) &#123; final MySynchronized mySynchronized = new MySynchronized(); final MySynchronized mySynchronized2 = new MySynchronized(); new Thread("thread1") &#123; public void run() &#123; synchronized (mySynchronized) &#123; try &#123; System.out.println(this.getName()+" start"); int i =1/0; //如果发生异常，jvm会将锁释放 Thread.sleep(5000); System.out.println(this.getName()+"醒了"); System.out.println(this.getName()+" end"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;.start(); new Thread("thread2") &#123; public void run() &#123; synchronized (mySynchronized) &#123; //争抢同一把锁时，线程1没释放之前，线程2只能等待// synchronized (mySynchronized2) &#123; //如果不是一把锁，可以看到两句话同时打印 System.out.println(this.getName()+" start"); System.out.println(this.getName()+" end"); &#125; &#125; &#125;.start(); &#125;&#125; 2.1.2. synchronized的缺陷synchronized是java中的一个关键字，也就是说是Java语言内置的特性。如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况： 获取锁的线程执行完了该代码块，然后线程释放对锁的占有； 线程执行发生异常，此时JVM会让线程自动释放锁。 例子1：如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。 例子2：当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。但是采用synchronized关键字来实现同步的话，就会导致一个问题：如果多个线程都只是进行读操作，当一个线程在进行读操作时，其他线程只能等待无法进行读操作。 因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。另外，通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。总的来说，也就是说Lock提供了比synchronized更多的功能。 2.2. lock2.2.1. lock和synchronized的区别 Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问； Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。2.2.2. java.util.concurrent.locks包下常用的类2.2.2.1. Lock首先要说明的就是Lock，通过查看Lock的源码可知，Lock是一个接口：1234567public interface Lock &#123; void lock(); void lockInterruptibly() throws InterruptedException; boolean tryLock(); boolean tryLock(long time, TimeUnit unit) throws InterruptedException; void unlock();&#125; 获取锁：lock()，lockInterruptibly()， tryLock()，tryLock(long time, TimeUnit unit)释放锁：unlock() 区别： lock()平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。由于在前面讲到如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。 tryLock()有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。 tryLock(long time, TimeUnit unit)和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。 lockInterruptibly()比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。注意，当一个线程获取了锁之后，是不会被interrupt()方法中断的。因此当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。 2.2.2.2. ReentrantLock直接使用lock接口的话，我们需要实现很多方法，不太方便，ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法，ReentrantLock，意思是“可重入锁”。 lock()的正确使用方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package cn.itcast_01_mythread.thread.lock;import java.util.ArrayList;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class MyLockTest &#123; private static ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); static Lock lock = new ReentrantLock(); // 注意这个地方 public static &lt;E&gt; void main(String[] args) &#123; new Thread() &#123; public void run() &#123; Thread thread = Thread.currentThread(); lock.lock(); try &#123; System.out.println(thread.getName() + "得到了锁"); for (int i = 0; i &lt; 5; i++) &#123; arrayList.add(i); &#125; &#125; catch (Exception e) &#123; // TODO: handle exception &#125; finally &#123; System.out.println(thread.getName() + "释放了锁"); lock.unlock(); &#125; &#125;; &#125;.start(); new Thread() &#123; public void run() &#123; Thread thread = Thread.currentThread(); lock.lock(); try &#123; System.out.println(thread.getName() + "得到了锁"); for (int i = 0; i &lt; 5; i++) &#123; arrayList.add(i); &#125; &#125; catch (Exception e) &#123; // TODO: handle exception &#125; finally &#123; System.out.println(thread.getName() + "释放了锁"); lock.unlock(); &#125; &#125;; &#125;.start(); &#125;&#125; tryLock()的使用方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package cn.itcast_01_mythread.thread.lock;import java.util.ArrayList;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 观察现象：一个线程获得锁后，另一个线程取不到锁，不会一直等待 * @author * */public class MyTryLock &#123; private static ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); static Lock lock = new ReentrantLock(); // 注意这个地方 public static void main(String[] args) &#123; new Thread() &#123; public void run() &#123; Thread thread = Thread.currentThread(); boolean tryLock = lock.tryLock(); System.out.println(thread.getName()+" "+tryLock); if (tryLock) &#123; try &#123; System.out.println(thread.getName() + "得到了锁"); for (int i = 0; i &lt; 5; i++) &#123; arrayList.add(i); &#125; &#125; catch (Exception e) &#123; // TODO: handle exception &#125; finally &#123; System.out.println(thread.getName() + "释放了锁"); lock.unlock(); &#125; &#125; &#125;; &#125;.start(); new Thread() &#123; public void run() &#123; Thread thread = Thread.currentThread(); boolean tryLock = lock.tryLock(); System.out.println(thread.getName()+" "+tryLock); if (tryLock) &#123; try &#123; System.out.println(thread.getName() + "得到了锁"); for (int i = 0; i &lt; 5; i++) &#123; arrayList.add(i); &#125; &#125; catch (Exception e) &#123; // TODO: handle exception &#125; finally &#123; System.out.println(thread.getName() + "释放了锁"); lock.unlock(); &#125; &#125; &#125;; &#125;.start(); &#125;&#125; lockInterruptibly()响应中断的使用方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package cn.itcast_01_mythread.thread.lock;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 观察现象：如果thread-0得到了锁，阻塞。。。thread-1尝试获取锁，如果拿不到，则可以被中断等待 * @author * */public class MyInterruptibly &#123; private Lock lock = new ReentrantLock(); public static void main(String[] args) &#123; MyInterruptibly test = new MyInterruptibly(); MyThread thread0 = new MyThread(test); MyThread thread1 = new MyThread(test); thread0.start(); thread1.start(); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; thread1.interrupt(); System.out.println("====================="); &#125; public void insert(Thread thread) throws InterruptedException&#123; lock.lockInterruptibly(); //注意，如果需要正确中断等待锁的线程，必须将获取锁放在外面，然后将InterruptedException抛出 try &#123; System.out.println(thread.getName()+"得到了锁"); long startTime = System.currentTimeMillis(); for( ; ;) &#123; if(System.currentTimeMillis() - startTime &gt;= Integer.MAX_VALUE) break; //插入数据 &#125; &#125; finally &#123; System.out.println(Thread.currentThread().getName()+"执行finally"); lock.unlock(); System.out.println(thread.getName()+"释放了锁"); &#125; &#125; &#125; class MyThread extends Thread &#123; private MyInterruptibly test = null; public MyThread(MyInterruptibly test) &#123; this.test = test; &#125; @Override public void run() &#123; try &#123; test.insert(Thread.currentThread()); &#125; catch (Exception e) &#123; System.out.println(Thread.currentThread().getName()+"被中断"); &#125; &#125;&#125; 2.2.2.3. ReadWriteLockReadWriteLock也是一个接口，在它里面只定义了两个方法：123456789101112131415public interface ReadWriteLock &#123; /** * Returns the lock used for reading. * * @return the lock used for reading. */ Lock readLock(); /** * Returns the lock used for writing. * * @return the lock used for writing. */ Lock writeLock();&#125; 一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的ReentrantReadWriteLock实现了ReadWriteLock接口。 2.2.2.4. ReentrantReadWriteLockReentrantReadWriteLock里面提供了很多丰富的方法，不过最主要的有两个方法：readLock()和writeLock()用来获取读锁和写锁。 ReentrantReadWriteLock具体用法 假如有多个线程要同时进行读操作的话，先看一下synchronized达到的效果123456789101112131415161718192021222324252627282930313233343536373839package cn.itcast_01_mythread.thread.lock;/** * 一个线程又要读又要写，用synchronize来实现的话，读写操作都只能锁住后一个线程一个线程地进行 * @author * */public class MySynchronizedReadWrite &#123; public static void main(String[] args) &#123; final MySynchronizedReadWrite test = new MySynchronizedReadWrite(); new Thread()&#123; public void run() &#123; test.get(Thread.currentThread()); &#125;; &#125;.start(); new Thread()&#123; public void run() &#123; test.get(Thread.currentThread()); &#125;; &#125;.start(); &#125; public synchronized void get(Thread thread) &#123; long start = System.currentTimeMillis(); int i=0; while(System.currentTimeMillis() - start &lt;= 1) &#123; i++; if(i%4==0)&#123; System.out.println(thread.getName()+"正在进行写操作"); &#125;else &#123; System.out.println(thread.getName()+"正在进行读操作"); &#125; &#125; System.out.println(thread.getName()+"读写操作完毕"); &#125;&#125; 改成用读写锁的话：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package cn.itcast_01_mythread.thread.lock;import java.util.concurrent.locks.ReentrantReadWriteLock;/** * 使用读写锁，可以实现读写分离锁定，读操作并发进行，写操作锁定单个线程 * * 如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。 * 如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。 * @author * */public class MyReentrantReadWriteLock &#123; private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); public static void main(String[] args) &#123; final MyReentrantReadWriteLock test = new MyReentrantReadWriteLock(); new Thread()&#123; public void run() &#123; test.get(Thread.currentThread()); test.write(Thread.currentThread()); &#125;; &#125;.start(); new Thread()&#123; public void run() &#123; test.get(Thread.currentThread()); test.write(Thread.currentThread()); &#125;; &#125;.start(); &#125; /** * 读操作,用读锁来锁定 * @param thread */ public void get(Thread thread) &#123; rwl.readLock().lock(); try &#123; long start = System.currentTimeMillis(); while(System.currentTimeMillis() - start &lt;= 1) &#123; System.out.println(thread.getName()+"正在进行读操作"); &#125; System.out.println(thread.getName()+"读操作完毕"); &#125; finally &#123; rwl.readLock().unlock(); &#125; &#125; /** * 写操作，用写锁来锁定 * @param thread */ public void write(Thread thread) &#123; rwl.writeLock().lock();; try &#123; long start = System.currentTimeMillis(); while(System.currentTimeMillis() - start &lt;= 1) &#123; System.out.println(thread.getName()+"正在进行写操作"); &#125; System.out.println(thread.getName()+"写操作完毕"); &#125; finally &#123; rwl.writeLock().unlock(); &#125; &#125;&#125; 注意： 不过要注意的是，如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。 如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。 2.3. Lock和synchronized的选择 Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现； synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁； Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断； 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。 Lock可以提高多个线程进行读操作的效率。 在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。 3. java并发包3.1. java并发包介绍JDK5.0 以后的版本都引入了高级并发特性，大多数的特性在java.util.concurrent 包中，是专门用于多线程发编程的，充分利用了现代多处理器和多核心系统的功能以编写大规模并发应用程序。主要包含原子量、并发集合、同步器、可重入锁，并对线程池的构造提供了强力的支持。 3.1.1. 线程池3.1.1.1. 创建方式五种创建方式 3.1.1.1.1. Single Thread Executor只有一个线程的线程池，因此所有提交的任务是顺序执行1234##### Cached Thread Pool 线程池里有很多线程需要同时执行，老的可用线程将被新的任务触发重新执行，&lt;font color=&quot;red&quot;&gt;如果线程超过60秒内没执行，那么将被终止并从池中删除&lt;/font&gt; ```Executors.newCachedThreadPool() 3.1.1.1.2. Fixed Thread Pool拥有固定线程数的线程池，如果没有任务执行，那么线程会一直等待12在构造函数中的参数4是线程池的大小，你可以随意设置，也可以和cpu的核数量保持一致，获取cpu的核数量 ```int cpuNums = Runtime.getRuntime().availableProcessors(); 3.1.1.1.3. Scheduled Thread Pool用来调度即将执行的任务的线程池，可能是不是直接执行, 每隔多久执行一次… 策略型的1234##### Single Thread Scheduled Pool 只有一个线程，用来调度任务在指定时间执行```Executors.newSingleThreadScheduledExecutor() 3.1.2. 线程池的使用提交 Runnable ，任务完成后 Future 对象返回 null调用excute,提交任务, 匿名Runable重写run方法, run方法里是业务逻辑123456789101112131415161718192021222324252627package cn.itcast_01_mythread.pool;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ThreadPoolWithRunable &#123; /** * 通过线程池执行线程 * @param args */ public static void main(String[] args) &#123; //创建一个线程池 ExecutorService pool = Executors.newCachedThreadPool(); for(int i = 1; i &lt; 5; i++)&#123; pool.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println("thread name: " + Thread.currentThread().getName()); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; pool.shutdown(); &#125;&#125; 提交 Callable，该方法返回一个 Future 实例表示任务的状态调用submit提交任务, 匿名Callable,重写call方法, 有返回值, 获取返回值会阻塞,一直要等到线程任务返回结果123456789101112131415161718192021222324252627282930313233343536373839package cn.itcast_01_mythread.pool;import java.util.ArrayList;import java.util.List;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;/** * callable 跟runnable的区别： * runnable的run方法不会有任何返回结果，所以主线程无法获得任务线程的返回值 * * callable的call方法可以返回结果，但是主线程在获取时是被阻塞，需要等待任务线程返回才能拿到结果 * @author * */public class ThreadPoolWithcallable &#123; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; ExecutorService pool = Executors.newFixedThreadPool(4); for(int i = 0; i &lt; 10; i++)&#123; Future&lt;String&gt; submit = pool.submit(new Callable&lt;String&gt;()&#123; @Override public String call() throws Exception &#123; //System.out.println("a"); Thread.sleep(5000); return "b--"+Thread.currentThread().getName(); &#125; &#125;); //从Future中get结果，这个方法是会被阻塞的，一直要等到线程任务返回结果 System.out.println(submit.get()); &#125; pool.shutdown(); &#125;&#125; 3.2. java并发包消息队列及在开源软件中的应用3.2.1. BlockingQueue也是java.util.concurrent下的主要用来控制线程同步的工具。主要的方法是：put、take一对阻塞存取；add、poll一对非阻塞存取。 插入: add(anObject):把anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则抛出异常,不好 offer(anObject):表示如果可能的话,将anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则返回false. put(anObject):把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断直到BlockingQueue里面有空间再继续, 有阻塞, 放不进去就等待 读取： poll(time):取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null; 取不到返回null take():取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到Blocking有新的对象被加入为止; 阻塞, 取不到就一直等 其他 int remainingCapacity();返回队列剩余的容量，在队列插入和获取的时候，不要瞎搞，数据可能不准, 不能保证数据的准确性 boolean remove(Object o); 从队列移除元素，如果存在，即移除一个或者更多，队列改 变了返回true public boolean contains(Object o); 查看队列是否存在这个元素，存在返回true int drainTo(Collection&lt;? super E&gt; c); //移除此队列中所有可用的元素,并将它们添加到给定 collection 中。取出放到集合中 int drainTo(Collection&lt;? super E&gt; c, int maxElements); 和上面方法的区别在于，指定了移动的数量;取出指定个数放到集合 BlockingQueue有四个具体的实现类,常用的两种实现类为： 3.2.2. ArrayBlockingQueue一个由数组支持的有界阻塞队列，规定大小的BlockingQueue,其构造函数必须带一个int参数来指明其大小.其所含的对象是以FIFO(先入先出)顺序排序的。 3.2.3. LinkedBlockingQueue大小不定的BlockingQueue,若其构造函数带一个规定大小的参数,生成的BlockingQueue有大小限制,若不带大小参数,所生成的BlockingQueue的大小由Integer.MAX_VALUE来决定.其所含的对象是以FIFO(先入先出)顺序排序的。LinkedBlockingQueue 可以指定容量，也可以不指定，不指定的话，默认最大是Integer.MAX_VALUE,其中主要用到put和take方法，put方法在队列满的时候会阻塞直到有队列成员被消费，take方法在队列空的时候会阻塞，直到有队列成员被放进来。 3.2.4. LinkedBlockingQueue和ArrayBlockingQueue区别LinkedBlockingQueue和ArrayBlockingQueue比较起来,它们背后所用的数据结构不一样,导致LinkedBlockingQueue的数据吞吐量要大于ArrayBlockingQueue,但在线程数量很大时其性能的可预见性低于ArrayBlockingQueue. 生产者消费者的示例代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134package cn.itcast_02_blockingqueue.main;import java.util.concurrent.BlockingQueue;import java.util.concurrent.LinkedBlockingQueue;import cn.itcast_02_blockingqueue.consumer.Consumer;import cn.itcast_02_blockingqueue.producer.Producer;public class Test &#123; public static void main(String[] args) throws Exception &#123; BlockingQueue&lt;String&gt; queue = new LinkedBlockingQueue&lt;String&gt;(2); // BlockingQueue&lt;String&gt; queue = new LinkedBlockingQueue&lt;String&gt;(); // 不设置的话，LinkedBlockingQueue默认大小为Integer.MAX_VALUE // BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;String&gt;(2); Consumer consumer = new Consumer(queue); Producer producer = new Producer(queue); for (int i = 0; i &lt; 3; i++) &#123; new Thread(producer, "Producer" + (i + 1)).start(); &#125; for (int i = 0; i &lt; 5; i++) &#123; new Thread(consumer, "Consumer" + (i + 1)).start(); &#125; new Thread(producer, "Producer" + (5)).start(); &#125;&#125;=====================================================================package cn.itcast_02_blockingqueue.main;import java.util.concurrent.BlockingQueue;import java.util.concurrent.LinkedBlockingQueue;public class TestBlockingQueue &#123; public static void main(String[] args) &#123; BlockingQueue&lt;String&gt; queue = new LinkedBlockingQueue&lt;String&gt;(2); // BlockingQueue&lt;String&gt; queue = new LinkedBlockingQueue&lt;String&gt;(); // 不设置的话，LinkedBlockingQueue默认大小为Integer.MAX_VALUE // BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;String&gt;(2); TestBlockingQueueConsumer consumer = new TestBlockingQueueConsumer(queue); TestBlockingQueueProducer producer = new TestBlockingQueueProducer(queue); for (int i = 0; i &lt; 3; i++) &#123; new Thread(producer, "Producer" + (i + 1)).start(); &#125; for (int i = 0; i &lt; 5; i++) &#123; new Thread(consumer, "Consumer" + (i + 1)).start(); &#125; new Thread(producer, "Producer" + (5)).start(); &#125;&#125;=====================================================================package cn.itcast_02_blockingqueue.main;import java.util.Random;import java.util.concurrent.BlockingQueue;public class TestBlockingQueueConsumer implements Runnable&#123; BlockingQueue&lt;String&gt; queue; Random random = new Random(); public TestBlockingQueueConsumer(BlockingQueue&lt;String&gt; queue)&#123; this.queue = queue; &#125; @Override public void run() &#123; try &#123; Thread.sleep(random.nextInt(10)); System.out.println(Thread.currentThread().getName()+ "trying..."); String temp = queue.take();//如果队列为空，会阻塞当前线程 System.out.println(Thread.currentThread().getName() + " get a job " +temp); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;=====================================================================package cn.itcast_02_blockingqueue.main;import java.util.Random;import java.util.concurrent.BlockingQueue;public class TestBlockingQueueProducer implements Runnable &#123; BlockingQueue&lt;String&gt; queue; Random random = new Random(); public TestBlockingQueueProducer(BlockingQueue&lt;String&gt; queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep(random.nextInt(10)); String task = Thread.currentThread().getName() + " made a product " + i; System.out.println(task); queue.put(task); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;=====================================================================package cn.itcast_02_blockingqueue.producer;import java.util.concurrent.BlockingQueue;public class Producer implements Runnable &#123; BlockingQueue&lt;String&gt; queue; public Producer(BlockingQueue&lt;String&gt; queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; try &#123; System.out.println("I have made a product:" + Thread.currentThread().getName()); String temp = "A Product, 生产线程：" + Thread.currentThread().getName(); queue.put(temp);//如果队列是满的话，会阻塞当前线程 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; =====================================================================package cn.itcast_02_blockingqueue.consumer;import java.util.concurrent.BlockingQueue;public class Consumer implements Runnable&#123; BlockingQueue&lt;String&gt; queue; public Consumer(BlockingQueue&lt;String&gt; queue)&#123; this.queue = queue; &#125; @Override public void run() &#123; try &#123; String consumer = Thread.currentThread().getName(); System.out.println(consumer); String temp = queue.take();//如果队列为空，会阻塞当前线程 System.out.println(consumer+"get a product:"+temp); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 4. java并发编程的一些总结4.1. 不应用线程池的缺点有些开发者图省事，遇到需要多线程处理的地方，直接new Thread(…).start()，对于一般场景是没问题的，但如果是在并发请求很高的情况下，就会有些隐患： 新建线程的开销。线程虽然比进程要轻量许多，但对于JVM来说，新建一个线程的代价还是挺大的，决不同于新建一个对象 资源消耗量。没有一个池来限制线程的数量，会导致线程的数量直接取决于应用的并发量，这样有潜在的线程数据巨大的可能，那么资源消耗量将是巨大的 稳定性。当线程数量超过系统资源所能承受的程度，稳定性就会成问题4.2. 制定执行策略在每个需要多线程处理的地方，不管并发量有多大，需要考虑线程的执行策略 任务以什么顺序执行 可以有多少个任务并发执行 可以有多少个任务进入等待执行队列 系统过载的时候，应该放弃哪些任务？如何通知到应用程序？ 一个任务的执行前后应该做什么处理 4.3. 线程池的类型不管是通过Executors创建线程池，还是通过Spring来管理，都得清楚知道有哪几种线程池： FixedThreadPool：定长线程池，提交任务时创建线程，直到池的最大容量，如果有线程非预期结束，会补充新线程 CachedThreadPool：可变线程池，它犹如一个弹簧，如果没有任务需求时，它回收空闲线程，如果需求增加，则按需增加线程，不对池的大小做限制 SingleThreadExecutor：单线程。处理不过来的任务会进入FIFO队列等待执行 SecheduledThreadPool：周期性线程池。支持执行周期性线程任务其实，这些不同类型的线程池都是通过构建一个ThreadPoolExecutor来完成的，所不同的是corePoolSize,maximumPoolSize,keepAliveTime,unit,workQueue,threadFactory这么几个参数。具体可以参见JDK DOC。 4.4. 线程池饱和策略由以上线程池类型可知，除了CachedThreadPool其他线程池都有饱和的可能，当饱和以后就需要相应的策略处理请求线程的任务，比如，达到上限时通过ThreadPoolExecutor.setRejectedExecutionHandler方法设置一个拒绝任务的策略，JDK提供了AbortPolicy、CallerRunsPolicy、DiscardPolicy、DiscardOldestPolicy几种策略，具体差异可见JDK DOC 4.5. 线程无依赖性多线程任务设计上尽量使得各任务是独立无依赖的，所谓依赖性可两个方面： 线程之间的依赖性。如果线程有依赖可能会造成死锁或饥饿 调用者与线程的依赖性。调用者得监视线程的完成情况，影响可并发量当然，在有些业务里确实需要一定的依赖性，比如调用者需要得到线程完成后结果，传统的Thread是不便完成的，因为run方法无返回值，只能通过一些共享的变量来传递结果，但在Executor框架里可以通过Future和Callable实现需要有返回值的任务，当然线程的异步性导致需要有相应机制来保证调用者能等待任务完成，关于Future和Callable的用法前文已讲解；]]></content>
      <categories>
        <category>大数据学习笔记</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据03-06-系统服务器上下线感知程序]]></title>
    <url>%2F2017%2F11%2F26%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2F%E5%A4%A7%E6%95%B0%E6%8D%AE03-06-%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E4%B8%8B%E7%BA%BF%E6%84%9F%E7%9F%A5%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[分布式服务注册，客户端获取等 1. zookeeper动态感知节点的示意图 2. 代码2.1. 客户端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package cn.itcast.bigdata.zkdist;import java.util.ArrayList;import java.util.List;import org.apache.zookeeper.KeeperException;import org.apache.zookeeper.WatchedEvent;import org.apache.zookeeper.Watcher;import org.apache.zookeeper.ZooKeeper;public class DistributedClient &#123; private static final String connectString = "mini1:2181,mini2:2181,mini3:2181"; private static final int sessionTimeout = 2000; private static final String parentNode = "/servers"; // 注意:加volatile的意义何在？ private volatile List&lt;String&gt; serverList; private ZooKeeper zk = null; /** * 创建到zk的客户端连接 * * @throws Exception */ public void getConnect() throws Exception &#123; zk = new ZooKeeper(connectString, sessionTimeout, new Watcher() &#123; @Override public void process(WatchedEvent event) &#123; // 收到事件通知后的回调函数（应该是我们自己的事件处理逻辑） try &#123; //重新更新服务器列表，并且注册了监听 getServerList(); &#125; catch (Exception e) &#123; &#125; &#125; &#125;); &#125; /** * 获取服务器信息列表 * * @throws Exception */ public void getServerList() throws Exception &#123; // 获取服务器子节点信息，并且对父节点进行监听 List&lt;String&gt; children = zk.getChildren(parentNode, true); // 先创建一个局部的list来存服务器信息 List&lt;String&gt; servers = new ArrayList&lt;String&gt;(); for (String child : children) &#123; // child只是子节点的节点名 byte[] data = zk.getData(parentNode + "/" + child, false, null); servers.add(new String(data)); &#125; // 把servers赋值给成员变量serverList，已提供给各业务线程使用 serverList = servers; //打印服务器列表 System.out.println(serverList); &#125; /** * 业务功能 * * @throws InterruptedException */ public void handleBussiness() throws InterruptedException &#123; System.out.println("client start working....."); Thread.sleep(Long.MAX_VALUE); &#125; public static void main(String[] args) throws Exception &#123; // 获取zk连接 DistributedClient client = new DistributedClient(); client.getConnect(); // 获取servers的子节点信息（并监听），从中获取服务器信息列表 client.getServerList(); // 业务线程启动 client.handleBussiness(); &#125;&#125; 2.2. 服务端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package cn.itcast.bigdata.zkdist;import org.apache.zookeeper.CreateMode;import org.apache.zookeeper.WatchedEvent;import org.apache.zookeeper.Watcher;import org.apache.zookeeper.ZooDefs.Ids;import org.apache.zookeeper.ZooKeeper;public class DistributedServer &#123; private static final String connectString = "mini1:2181,mini2:2181,mini3:2181"; private static final int sessionTimeout = 2000; private static final String parentNode = "/servers"; private ZooKeeper zk = null; /** * 创建到zk的客户端连接 * * @throws Exception */ public void getConnect() throws Exception &#123; zk = new ZooKeeper(connectString, sessionTimeout, new Watcher() &#123; @Override public void process(WatchedEvent event) &#123; // 收到事件通知后的回调函数（应该是我们自己的事件处理逻辑） System.out.println(event.getType() + "---" + event.getPath()); try &#123; zk.getChildren("/", true); &#125; catch (Exception e) &#123; &#125; &#125; &#125;); &#125; /** * 向zk集群注册服务器信息 * * @param hostname * @throws Exception */ public void registerServer(String hostname) throws Exception &#123; String create = zk.create(parentNode + "/server", hostname.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL); System.out.println(hostname + "is online.." + create); &#125; /** * 业务功能 * * @throws InterruptedException */ public void handleBussiness(String hostname) throws InterruptedException &#123; System.out.println(hostname + "start working....."); Thread.sleep(Long.MAX_VALUE); &#125; public static void main(String[] args) throws Exception &#123; // 获取zk连接 DistributedServer server = new DistributedServer(); server.getConnect(); // 利用zk连接注册服务器信息 server.registerServer(args[0]); // 启动业务功能 server.handleBussiness(args[0]); &#125;&#125;]]></content>
      <categories>
        <category>大数据学习笔记</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据03-05-java api]]></title>
    <url>%2F2017%2F11%2F26%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2F%E5%A4%A7%E6%95%B0%E6%8D%AE03-05-java-api%2F</url>
    <content type="text"><![CDATA[java api 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package cn.itcast.bigdata.zk;import java.io.IOException;import java.util.List;import org.apache.zookeeper.CreateMode;import org.apache.zookeeper.KeeperException;import org.apache.zookeeper.WatchedEvent;import org.apache.zookeeper.Watcher;import org.apache.zookeeper.ZooDefs.Ids;import org.apache.zookeeper.ZooKeeper;import org.apache.zookeeper.data.Stat;import org.junit.Before;import org.junit.Test;public class SimpleZkClient &#123; private static final String connectString = "mini1:2181,mini2:2181,mini3:2181"; private static final int sessionTimeout = 2000; ZooKeeper zkClient = null; @Before public void init() throws Exception &#123; zkClient = new ZooKeeper(connectString, sessionTimeout, new Watcher() &#123; @Override public void process(WatchedEvent event) &#123; // 收到事件通知后的回调函数（应该是我们自己的事件处理逻辑） System.out.println(event.getType() + "---" + event.getPath()); try &#123; zkClient.getChildren("/", true); &#125; catch (Exception e) &#123; &#125; &#125; &#125;); &#125; /** * 数据的增删改查 * * @throws InterruptedException * @throws KeeperException */ // 创建数据节点到zk中 public void testCreate() throws KeeperException, InterruptedException &#123; // 参数1：要创建的节点的路径 参数2：节点大数据 参数3：节点的权限 参数4：节点的类型 String nodeCreated = zkClient.create("/eclipse", "hellozk".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); //上传的数据可以是任何类型，但都要转成byte[] &#125; //判断znode是否存在 @Test public void testExist() throws Exception&#123; Stat stat = zkClient.exists("/eclipse", false); System.out.println(stat==null?"not exist":"exist"); &#125; // 获取子节点 @Test public void getChildren() throws Exception &#123; List&lt;String&gt; children = zkClient.getChildren("/", true); for (String child : children) &#123; System.out.println(child); &#125; Thread.sleep(Long.MAX_VALUE); &#125; //获取znode的数据 @Test public void getData() throws Exception &#123; byte[] data = zkClient.getData("/eclipse", false, null); System.out.println(new String(data)); &#125; //删除znode @Test public void deleteZnode() throws Exception &#123; //参数2：指定要删除的版本，-1表示删除所有版本 zkClient.delete("/eclipse", -1); &#125; //删除znode @Test public void setData() throws Exception &#123; zkClient.setData("/app1", "imissyou angelababy".getBytes(), -1); byte[] data = zkClient.getData("/app1", false, null); System.out.println(new String(data)); &#125;&#125;]]></content>
      <categories>
        <category>大数据学习笔记</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据03-04-zookeeper集群自动启动脚本及export变量作用域的解析]]></title>
    <url>%2F2017%2F11%2F21%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2F%E5%A4%A7%E6%95%B0%E6%8D%AE03-04-zookeeper%E9%9B%86%E7%BE%A4%E8%87%AA%E5%8A%A8%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC%E5%8F%8Aexport%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[export A=1 定义的变量，会对自己所在的shell进程及其子进程生效 B=1 定义的变量，只对自己所在的shell进程生效 在script.sh中定义的变量，在当前登录的shell进程中 source script.sh 时，脚本中定义的变量也会进入当前登录的进程 123456#!/bin/shecho "start zkServer..."for i in 1 2 3do ssh zk$i "source /etc/profile;/home/vagrant/apps/zookeeper/bin/zkServer.sh start"done 提示输入密码，配置免密登录 12ssh-keygen ssh-copy-id zk1 可以放到/root/bin 目录下，该目录直接就在环境变量中，不需要配置，可以在其他位置执行了]]></content>
      <categories>
        <category>大数据学习笔记</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据03-03-zookeeper-命令行客户端及znode数据结构类型监听等功能]]></title>
    <url>%2F2017%2F11%2F19%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2F%E5%A4%A7%E6%95%B0%E6%8D%AE03-03-zookeeper-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%8Aznode%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E7%9B%91%E5%90%AC%E7%AD%89%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[1. 进入客户端1234bin/zkCli.sh (连到本机)connect zk2:2181（连到zk2机器上）[zk: zk2:2181(CONNECTED) 3] 2. zookeeper结构2.1. 特性 Zookeeper：一个leader，多个follower组成的集群 全局数据一致：每个server保存一份相同的数据副本，client无论连接到哪个server，数据都是一致的 分布式读写，更新请求转发，由leader实施 更新请求顺序进行，来自同一个client的更新请求按其发送顺序依次执行 数据更新原子性，一次数据更新要么成功，要么失败 实时性，在一定时间范围内，client能读到最新数据 2.2. 数据结构 层次化的目录结构，命名符合常规文件系统规范(见下图) 每个节点在zookeeper中叫做znode,并且其有一个唯一的路径标识 节点Znode可以包含数据和子节点（但是EPHEMERAL类型的节点不能有子节点，下一页详细讲解） 客户端应用可以在节点上设置监视器（后续详细讲解） 2.3. 数据结构图 2.4. 节点类型 Znode有两种类型： 短暂（ephemeral）（断开连接自己删除） 持久（persistent）（断开连接不删除） Znode有四种形式的目录节点（默认是persistent ） PERSISTENT PERSISTENT_SEQUENTIAL（持久序列/test0000000019 ） EPHEMERAL EPHEMERAL_SEQUENTIAL 创建znode时设置顺序标识，znode名称后会附加一个值，顺序号是一个单调递增的计数器，由父节点维护 在分布式系统中，顺序号可以被用于为所有的事件进行全局排序，这样客户端可以通过顺序号推断事件的顺序 3. 命令行操作 运行 zkCli.sh –server 进入命令行工具 1234567891011121314151617181920212223[zk: zk2:2181(CONNECTED) 2] helpZooKeeper -server host:port cmd args connect host:port get path [watch] ls path [watch] set path data [version] rmr path delquota [-n|-b] path quit printwatches on|off create [-s] [-e] path data acl stat path [watch] close ls2 path [watch] history listquota path setAcl path acl getAcl path sync path redo cmdno addauth scheme auth delete path [version] setquota -n|-b val path 使用 ls 命令来查看当前 ZooKeeper 中所包含的内容： 12[zk: zk2:2181(CONNECTED) 3] ls /[zookeeper] 创建一个新的 znode ，使用 create /zk myData 。这个命令创建了一个新的 znode 节点“ zk ”以及与它关联的字符串： 12[zk: zk2:2181(CONNECTED) 4] create /app 1234Created /app 我们运行 get 命令来确认 znode 是否包含我们所创建的字符串： 12345678910111213[zk: zk2:2181(CONNECTED) 5] get /app1234cZxid = 0x300000004ctime = Sun Nov 19 15:48:32 UTC 2017mZxid = 0x300000004mtime = Sun Nov 19 15:48:32 UTC 2017pZxid = 0x300000004cversion = 0dataVersion = 0aclVersion = 0ephemeralOwner = 0x0dataLength = 4numChildren = 0 1234[zk: localhost:2181(CONNECTED) 4] get /app watch#监听这个节点的变化,当另外一个客户端改变/app,它会打出下面的#WATCHER::#WatchedEvent state:SyncConnected type:NodeDataChanged path:/app 下面我们通过 set 命令来对 zk 所关联的字符串进行设置： 1234567891011121314151617181920212223242526[zk: zk2:2181(CONNECTED) 6] set /app 222cZxid = 0x300000004ctime = Sun Nov 19 15:48:32 UTC 2017mZxid = 0x300000005mtime = Sun Nov 19 15:50:46 UTC 2017pZxid = 0x300000004cversion = 0dataVersion = 1aclVersion = 0ephemeralOwner = 0x0dataLength = 3numChildren = 0[zk: zk2:2181(CONNECTED) 7] get /app222cZxid = 0x300000004ctime = Sun Nov 19 15:48:32 UTC 2017mZxid = 0x300000005mtime = Sun Nov 19 15:50:46 UTC 2017pZxid = 0x300000004cversion = 0dataVersion = 1aclVersion = 0ephemeralOwner = 0x0dataLength = 3numChildren = 0 下面我们将刚才创建的 znode 删除：只能删除没有子节点的节点 123[zk: zk2:2181(CONNECTED) 8] delete /app[zk: zk2:2181(CONNECTED) 9] ls /[zookeeper] 删除节点：rmr 删除节点及其子节点 12345[zk: zk2:2181(CONNECTED) 11] create /app2 12Created /app2[zk: zk2:2181(CONNECTED) 12] rmr /app2[zk: zk2:2181(CONNECTED) 13] ls / [zookeeper]]]></content>
      <categories>
        <category>大数据学习笔记</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据03-02-zookeeper 简介]]></title>
    <url>%2F2017%2F11%2F19%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2F%E5%A4%A7%E6%95%B0%E6%8D%AE03-02-zookeeper-%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[1. 学软件，框架需要明白三点 应用场景：干什么的 在哪里用的 核心工作机制流程功能：组成，角色 怎么用 再深一层，原理细节：选择性的深入了解，重要框架 2. zookeeperzookeeper会用 3. 概念简介分布式协调服务， zookeeper是为别的分布式程序服务的 Zookeeper本身就是一个分布式程序（只要有半数以上节点存活，zk就能正常服务） Zookeeper所提供的服务涵盖：主从协调、服务器节点动态上下线、统一配置管理、分布式共享锁、统一名称服务…… 虽然说可以提供各种服务，但是zookeeper在底层其实只提供了两个功能： 管理(存储，读取)用户程序提交的数据； 并为用户程序提供数据节点监听服务； 3.1. zookeeper一些应用场景 3.2. 集群角色分配原理 3.3. 集群机制半数机制：集群中半数以上机器存活，集群可用。zookeeper适合装在奇数台机器上！！！ 3.4. 安装3.4.1. 上传文件1zookeeper-3.4.5.tar.gz 3.4.2. 解压1tar -zxvf zookeeper-3.4.5.tar.gz 3.4.3. 重命名1mv zookeeper-3.4.5 zookeeper（重命名文件夹zookeeper-3.4.5为zookeeper） 3.4.4. 修改环境变量 su root (切换到root用户) vi /etc/profile (修改文件) 添加内容： 12export ZOOKEEPER_HOME=/home/hadoop/zookeeperexport PATH=$PATH:$ZOOKEEPER_HOME/bin 重新编译文件：source /etc/profile 注意：3台zookeeper都需要修改 修改完成后切换回hadoop用户：1su - hadoop 3.4.5. 修改配置文件 用hadoop用户操作 12cd zookeeper/confcp zoo_sample.cfg zoo.cfg vi zoo.cfg 添加内容： 12345dataDir=/home/hadoop/zookeeper/datadataLogDir=/home/hadoop/zookeeper/logserver.1=zk1:2888:3888 (主机名, 心跳端口、数据端口)server.2=zk2:2888:3888server.3=zk3:2888:3888 3.4.6. 创建文件夹123cd /home/hadoop/zookeeper/mkdir -m 755 datamkdir -m 755 log 3.4.7. 在data文件夹下新建myid文件，myid的文件内容为：cd datavi myid添加内容：（数字递增）11 上面的操作都是所有机器一起操作的，如果是单台操作需要把内容复制到其他的机器上 3.4.7.1. 将集群下发到其他机器上12scp -r /home/hadoop/zookeeper hadoop@slave2:/home/hadoop/scp -r /home/hadoop/zookeeper hadoop@slave3:/home/hadoop/ 3.4.7.2. 修改其他机器的配置文件12到slave2上：修改myid为：2到slave3上：修改myid为：3 3.4.8. 启动每台机器1/root/zookeeper/bin/zkServer.sh start 3.4.9. 查看集群状态 jps（查看进程） zkServer.sh status（查看集群状态，主从信息） 4. 其他4.1. 一般集群公司内部使用的时候防火墙是关掉了，不会被外界访问12service iptables stopchkconfig iptables off 4.2. 遇到错误启动不了查看bin下的 zookeeper.out 4.3. 注意conf/zoo.cfg中节点ID必须与myid文件中的id相对应]]></content>
      <categories>
        <category>大数据学习笔记</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-next 本地搜索]]></title>
    <url>%2F2017%2F11%2F14%2F%E6%9D%82%E8%AE%B0%2Fhexo-next-%E6%9C%AC%E5%9C%B0%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[之前用的algolia用不了了，应该是收费。查找了帖子做了本地搜索，感觉也很不错，主要是不用担心不好使了。 1. local search1.1. 安装hexo-generator-searchdb在站点根目录通过gitbash安装1npm install hexo-generator-searchdb --save 1.2. 添加search字段在站点下_config.yml中添加search字段12345search: path: search.xml field: post format: html limit: 10000 1.3. 在themes\next_config.yml主题配置中找到12local_search: enable: true 将enable的值改成true 2. 参考链接Hexo的Next主题配置]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据03-01-自动化部署脚本]]></title>
    <url>%2F2017%2F11%2F14%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2F%E5%A4%A7%E6%95%B0%E6%8D%AE03-01-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[实现ssh免密登录及jdk的自动安装 1. boot.sh免密登录 及复制安装脚本到目标机器12345678910111213141516171819202122232425262728293031#!/bin/bashSERVERS="node-3.itcast.cn node-4.itcast.cn"PASSWORD=123456BASE_SERVER=172.16.203.100auto_ssh_copy_id() &#123; expect -c "set timeout -1; spawn ssh-copy-id $1; expect &#123; *(yes/no)* &#123;send -- yes\r;exp_continue;&#125; *assword:* &#123;send -- $2\r;exp_continue;&#125; eof &#123;exit 0;&#125; &#125;";&#125;ssh_copy_id_to_all() &#123; for SERVER in $SERVERS do auto_ssh_copy_id $SERVER $PASSWORD done&#125;ssh_copy_id_to_allfor SERVER in $SERVERSdo scp install.sh root@$SERVER:/root ssh root@$SERVER /root/install.shdone 2. install_everyone.sh安装jdk12345678910#!/bin/bashBASE_SERVER=mini4yum install -y wgetwget $BASE_SERVER/soft/jdk-7u45-linux-x64.tar.gztar -zxvf jdk-7u45-linux-x64.tar.gz -C /usr/localcat &gt;&gt; /etc/profile &lt;&lt; EOFexport JAVA_HOME=/usr/local/jdk1.7.0_45export PATH=\$PATH:\$JAVA_HOME/binEOF 说明: expect 模拟人机交互 EOF临时文本输入]]></content>
      <categories>
        <category>大数据学习笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>大数据</tag>
        <tag>centos7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据02-01-1 linux本地yum库]]></title>
    <url>%2F2017%2F11%2F14%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2F%E5%A4%A7%E6%95%B0%E6%8D%AE02-01-1-linux%E6%9C%AC%E5%9C%B0yum%E5%BA%93%2F</url>
    <content type="text"><![CDATA[1. 本地yum仓库的安装配置1.1. 两种方式：1.1.1. 每一台机器都配一个本地文件系统上的yum仓库 file:///packege/path/1.1.2. 在局域网内部配置一台节点(server-base)的本地文件系统yum仓库，然后将其发布到web服务器中，其他节点就可以通过http://server-base/pagekege/path/ 制作流程： 先挑选一台机器mini4，挂载一个系统光盘到本地目录/mnt/cdrom， 然后启动一个httpd服务器， 将/mnt/cdrom 软连接到httpd服务器的/var/www/html目录中 (cd /var/www/html; ln -s /mnt/cdrom ./centos ) 然后通过网页访问测试一下： http://mini4/centos 会看到光盘的目录内容 至此：网络版yum私有仓库已经建立完毕剩下就是去各台yum的客户端配置这个http地址到repo配置文件中 2. 无论哪种配置，都需要先将光盘挂在到本地文件目录中 mount -t iso9660 /dev/cdrom /mnt/cdrom 为了避免每次重启后都要手动mount，可以在/etc/fstab中加入一行挂载配置，即可自动挂载 vi /etc/fstab /dev/cdrom /mnt/cdrom iso9660 defaults 0 0 3. minimal安装的系统出现的问题：缺各种命令，安装软件时缺各种依赖scp命令都没有：yum install -y openssh-clients每台机器上都要安装才行]]></content>
      <categories>
        <category>大数据学习笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>大数据</tag>
        <tag>centos7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据02-05-shell编程-awk命令]]></title>
    <url>%2F2017%2F11%2F06%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2F%E5%A4%A7%E6%95%B0%E6%8D%AE02-05-shell%E7%BC%96%E7%A8%8B-awk%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1. 简介awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。 awk有3个不同版本: awk、nawk和gawk，未作特别说明，一般指gawk，gawk 是 AWK 的 GNU 版本。 awk其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。实际上 AWK 的确拥有自己的语言： AWK 程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。 2. 使用方法 awk &#39;{pattern + action}&#39; {filenames} 尽管操作可能会很复杂，但语法总是这样，其中 pattern 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令。花括号（{}）不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。 pattern就是要表示的正则表达式，用斜杠括起来。 awk语言的最基本功能是在文件或者字符串中基于指定规则浏览和抽取信息，awk抽取信息后，才能进行其他文本操作。完整的awk脚本通常用来格式化文本文件中的信息。 通常，awk是以文件的一行为处理单位的。awk每接收文件的一行，然后执行相应的命令，来处理文本。 2.1. 调用awk有三种方式调用awk 2.1.1. 命令行方式 awk [-F field-separator] ‘commands’ input-file(s)其中，commands 是真正awk命令，[-F域分隔符]是可选的。 input-file(s) 是待处理的文件。在awk中，文件的每一行中，由域分隔符分开的每一项称为一个域。通常，在不指名-F域分隔符的情况下，默认的域分隔符是空格。 2.1.2. shell脚本方式将所有的awk命令插入一个文件，并使awk程序可执行，然后awk命令解释器作为脚本的首行，一遍通过键入脚本名称来调用。相当于shell脚本首行的：#!/bin/sh可以换成：#!/bin/awk 2.1.3. 将所有的awk命令插入一个单独文件，然后调用： awk -f awk-script-file input-file(s)其中，-f选项加载awk-script-file中的awk脚本，input-file(s)跟上面的是一样的。 本章重点介绍命令行方式。 2.2. 入门实例假设last -n 5的输出如下 [root@www ~]# last -n 5 &lt;==仅取出前五行 12345root pts/1 192.168.1.100 Tue Feb 10 11:21 still logged inroot pts/1 192.168.1.100 Tue Feb 10 00:46 - 02:28 (01:41)root pts/1 192.168.1.100 Mon Feb 9 11:41 - 18:30 (06:48)dmtsai pts/1 192.168.1.100 Mon Feb 9 11:41 - 11:41 (00:00)root tty1 Fri Sep 5 14:09 - 14:10 (00:01) 如果只是显示最近登录的5个帐号 123456#last -n 5 | awk &apos;&#123;print $1&#125;&apos;rootrootrootdmtsairoot awk工作流程是这样的：读入有’\n’换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域。默认域分隔符是”空白键” 或 “[tab]键”,所以$1表示登录用户，$3表示登录用户ip,以此类推。 如果只是显示/etc/passwd的账户 12345#cat /etc/passwd |awk -F &apos;:&apos; &apos;&#123;print $1&#125;&apos; rootdaemonbinsys 这种是awk+action的示例，每行都会执行action{print $1}。 -F指定域分隔符为’:’。 如果只是显示/etc/passwd的账户和账户对应的shell,而账户与shell之间以tab键分割 123456789#cat /etc/passwd |awk -F &apos;:&apos; &apos;&#123;print $1&quot;\t&quot;$7&#125;&apos;root /bin/bashdaemon /bin/shbin /bin/shsys /bin/sh``` 如果只是显示/etc/passwd的账户和账户对应的shell,而账户与shell之间以逗号分割,而且在所有行添加列名name,shell,在最后一行添加&quot;blue,/bin/nosh&quot;。 cat /etc/passwd |awk -F ‘:’ ‘BEGIN {print “name,shell”} {print $1”,”$7} END {print “blue,/bin/nosh”}’name,shellroot,/bin/bashdaemon,/bin/shbin,/bin/shsys,/bin/sh….blue,/bin/nosh 123456789101112awk工作流程是这样的：先执行BEGING，然后读取文件，读入有/n换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域,随后开始执行模式所对应的动作action。接着开始读入第二条记录······直到所有的记录都读完，最后执行END操作。 搜索/etc/passwd有root关键字的所有行&gt; #awk -F: &apos;/root/&apos; /etc/passwdroot:x:0:0:root:/root:/bin/bash这种是pattern的使用示例，匹配了pattern(这里是root)的行才会执行action(没有指定action，默认输出每行的内容)。搜索支持正则，例如找root开头的: ```awk -F: &apos;/^root/&apos; /etc/passwd 搜索/etc/passwd有root关键字的所有行，并显示对应的shell awk -F: ‘/root/{print $7}’ /etc/passwd/bin/bash 这里指定了action{print $7} 2.3. awk内置变量awk有许多内置变量用来设置环境信息，这些变量可以被改变，下面给出了最常用的一些变量。 ARGC 命令行参数个数 ARGV 命令行参数排列 ENVIRON 支持队列中系统环境变量的使用 FILENAME awk浏览的文件名 FNR 浏览文件的记录数 FS 设置输入域分隔符，等价于命令行 -F选项 NF 浏览记录的域的个数 NR 已读的记录数 OFS 输出域分隔符 ORS 输出记录分隔符 RS 控制记录分隔符 此外,$0变量是指整条记录。$1表示当前行的第一个域,$2表示当前行的第二个域,……以此类推。 统计/etc/passwd:文件名，每行的行号，每行的列数，对应的完整行内容: #awk -F ‘:’ ‘{print “filename:” FILENAME “,linenumber:” NR “,columns:” NF “,linecontent:”$0}’ /etc/passwd123456789101112131415161718192021222324252627filename:/etc/passwd,linenumber:1,columns:7,linecontent:root:x:0:0:root:/root:/bin/bashfilename:/etc/passwd,linenumber:2,columns:7,linecontent:daemon:x:1:1:daemon:/usr/sbin:/bin/shfilename:/etc/passwd,linenumber:3,columns:7,linecontent:bin:x:2:2:bin:/bin:/bin/shfilename:/etc/passwd,linenumber:4,columns:7,linecontent:sys:x:3:3:sys:/dev:/bin/sh``` 使用printf替代print,可以让代码更加简洁，易读 &gt; awk -F &apos;:&apos; &apos;&#123;printf(&quot;filename:%s,linenumber:%s,columns:%s,linecontent:%s\n&quot;,FILENAME,NR,NF,$0)&#125;&apos; /etc/passwd ## 2.4. print和printfawk中同时提供了print和printf两种打印输出的函数。其中print函数的参数可以是变量、数值或者字符串。字符串必须用双引号引用，参数用逗号分隔。如果没有逗号，参数就串联在一起而无法区分。这里，逗号的作用与输出文件的分隔符的作用是一样的，只是后者是空格而已。printf函数，其用法和c语言中printf基本相似,可以格式化字符串,输出复杂时，printf更加好用，代码更易懂。%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% # 3. awk编程 变量和赋值除了awk的内置变量，awk还可以自定义变量。## 3.1. 下面统计/etc/passwd的账户人数 awk ‘{count++;print $0;} END{print “user count is “, count}’ /etc/passwdroot:x:0:0:root:/root:/bin/bash……user count is 40 123456count是自定义变量。之前的action&#123;&#125;里都是只有一个print,其实print只是一个语句，而action&#123;&#125;可以有多个语句，以;号隔开。 这里没有初始化count，虽然默认是0，但是妥当的做法还是初始化为0: awk ‘BEGIN {count=0;print “[start]user count is “, count} {count=count+1;print $0;} END{print “[end]user count is “, count}’ /etc/passwd[start]user count is 0root:x:0:0:root:/root:/bin/bash…[end]user count is 40 12统计某个文件夹下的文件占用的字节数 ls -l |awk ‘BEGIN {size=0;} {size=size+$5;} END{print “[end]size is “, size}’[end]size is 8657198 12如果以M为单位显示: ls -l |awk ‘BEGIN {size=0;} {size=size+$5;} END{print “[end]size is “, size/1024/1024,”M”}’[end]size is 8.25889 M 1234567注意，统计不包括文件夹的子目录。 ### 3.1.1. 条件语句 awk中的条件语句是从C语言中借鉴来的，见如下声明方式： if (expression) { statement; statement; … …} if (expression) { statement;} else { statement2;} if (expression) { statement1;} else if (expression1) { statement2;} else { statement3;} 12统计某个文件夹下的文件占用的字节数,过滤4096大小的文件(一般都是文件夹): ls -l |awk ‘BEGIN {size=0;print “[start]size is “, size} {if($5!=4096){size=size+$5;}} END{print “[end]size is “, size/1024/1024,”M”}’[end]size is 8.22339 M 1234567891011121314### 循环语句awk中的循环语句同样借鉴于C语言，支持while、do/while、for、break、continue，这些关键字的语义和C语言中的语义完全相同。 ### 数组 因为awk中数组的下标可以是数字和字母，数组的下标通常被称为关键字(key)。值和关键字都存储在内部的一张针对key/value应用hash的表格里。由于hash不是顺序存储，因此在显示数组内容时会发现，它们并不是按照你预料的顺序显示出来的。数组和变量一样，都是在使用时自动创建的，awk也同样会自动判断其存储的是数字还是字符串。一般而言，awk中的数组用来从记录中收集信息，可以用于计算总和、统计单词以及跟踪模板被匹配的次数等等。 显示/etc/passwd的账户 awk -F ‘:’ ‘BEGIN {count=0;} {name[count] = $1;count++;}; END{for (i = 0; i &lt; NR; i++) print i, name[i]}’ /etc/passwd0 root1 daemon2 bin3 sys4 sync5 games…… ```这里使用for循环遍历数组 awk编程的内容极多，这里只罗列简单常用的用法，更多请参考 http://www.gnu.org/software/gawk/manual/gawk.html]]></content>
      <categories>
        <category>大数据学习笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>大数据</tag>
        <tag>linux命令</tag>
        <tag>centos7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据02-04-shell编程-sed命令]]></title>
    <url>%2F2017%2F11%2F06%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2F%E5%A4%A7%E6%95%B0%E6%8D%AE02-04-shell%E7%BC%96%E7%A8%8B-sed%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1. Sed简介sed 是一种在线编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。以下介绍的是Gnu版本的Sed 3.02。做备份,以后速查用. 1.1. 定址可以通过定址来定位你所希望编辑的行，该地址用数字构成，用逗号分隔的两个行数表示以这两行为起止的行的范围（包括行数表示的那两行）。如1，3表示1，2，3行，美元符号($)表示最后一行。范围可以通过数据，正则表达式或者二者结合的方式确定 。 1.2. Sed命令调用sed命令有两种形式： sed [options] ‘command’ file(s) sed [options] -f scriptfile file(s) a在当前行后面加入一行文本。 b lable分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。 c用新的文本改变本行的文本。 d从模板块（Pattern space）位置删除行。 D删除模板块的第一行。 i在当前行上面插入文本。 h拷贝模板块的内容到内存中的缓冲区。 H追加模板块的内容到内存中的缓冲区 g获得内存缓冲区的内容，并替代当前模板块中的文本。 G获得内存缓冲区的内容，并追加到当前模板块文本的后面。 l列表不能打印字符的清单。 n读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。 N追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。 p打印模板块的行。 P（大写）打印模板块的第一行。 q退出Sed。 r file从file中读行。 t labelif分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。 T label错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。 w file写并追加模板块到file末尾。 W file写并追加模板块的第一行到file末尾。 !表示后面的命令对所有没有被选定的行发生作用。 s/re/string用string替换正则表达式re。 =打印当前行号码。 #把注释扩展到下一个换行符以前。1.2.1. 以下的是替换标记 g表示行内全面替换。 p表示打印行。 w表示把行写入一个文件。 x表示互换模板块中的文本和缓冲区中的文本。 y表示把一个字符翻译为另外的字符（但是不用于正则表达式） 1.3. 选项-e command, --expression=command允许多台编辑。 -h, –help打印帮助，并显示bug列表的地址。 -n, –quiet, –silent取消默认输出。 -f, –filer=script-file引导sed脚本文件名。 -V, –version打印版本和版权信息。 1.4. 元字符集^锚定行的开始 如：/^sed/匹配所有以sed开头的行。$ 锚定行的结束 如：/sed$/匹配所有以sed结尾的行。. 匹配一个非换行符的字符 如：/s.d/匹配s后接一个任意字符，然后是d。* 匹配零或多个字符 如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。[] 匹配一个指定范围内的字符，如/[Ss]ed/匹配sed和Sed。[^] 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。(..) 保存匹配的字符，如s/(love)able/\1rs，loveable被替换成lovers。&amp; 保存搜索字符用来替换其他字符，如s/love/&amp;/，love这成love。\&lt; 锚定单词的开始，如:/\ 锚定单词的结束，如/love>/匹配包含以love结尾的单词的行。x{m} 重复字符x，m次，如：/o{5}/匹配包含5个o的行。x{m,} 重复字符x,至少m次，如：/o{5,}/匹配至少有5个o的行。x{m,n} 重复字符x，至少m次，不多于n次，如：/o{5,10}/匹配5–10个o的行。1.5. 实例1.5.1. 删除：d命令 $ sed ‘2d’ example—–删除example文件的第二行。 $ sed ‘2,$d’ example—–删除example文件的第二行到末尾所有行。 $ sed ‘$d’ example—–删除example文件的最后一行。 $ sed ‘/test/‘d example—–删除example文件所有包含test的行。1.5.2. 替换：s命令 $ sed ‘s/test/mytest/g’ example—–在整行范围内把test替换为mytest。如果没有g标记，则只有每行第一个匹配的test被替换成mytest。 $ sed -n ‘s/^test/mytest/p’ example—–(-n)选项和p标志一起使用表示只打印那些发生替换的行。也就是说，如果某一行开头的test被替换成mytest，就打印它。 $ sed ‘s/^192.168.0.1/&amp;localhost/‘ example—–&amp;符号表示替换换字符串中被找到的部份。所有以192.168.0.1开头的行都会被替换成它自已加 localhost，变成192.168.0.1localhost。 $ sed -n ‘s/(love)able/\1rs/p’ example—–love被标记为1，所有loveable会被替换成lovers，而且替换的行会被打印出来。 $ sed ‘s#10#100#g’ example—–不论什么字符，紧跟着s命令的都被认为是新的分隔符，所以，“#”在这里是分隔符，代替了默认的“/”分隔符。表示把所有10替换成100。选定行的范围：逗号 $ sed -n ‘/test/,/check/p’ example—–所有在模板test和check所确定的范围内的行都被打印。 $ sed -n ‘5,/^test/p’ example—–打印从第五行开始到第一个包含以test开始的行之间的所有行。 $ sed ‘/test/,/check/s/$/sed test/‘ example—–对于模板test和west之间的行，每行的末尾用字符串sed test替换。1.5.3. 多点编辑：e命令 $ sed -e ‘1,5d’ -e ‘s/test/check/‘ example—–(-e)选项允许在同一行里执行多条命令。如例子所示，第一条命令删除1至5行，第二条命令用check替换test。命令的执 行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果。 $ sed –expression=’s/test/check/‘ –expression=’/love/d’ example—–一个比-e更好的命令是–expression。它能给sed表达式赋值。1.5.4. 从文件读入：r命令 $ sed ‘/test/r file’ example—–file里的内容被读进来，显示在与test匹配的行后面，如果匹配多行，则file的内容将显示在所有匹配行的下面。1.5.5. 写入文件：w命令 $ sed -n ‘/test/w file’ example—–在example中所有包含test的行都被写入file里。 1.5.6. 追加命令：a命令 $ sed ‘/^test/a\—&gt;this is a example’ example ‘—–&gt;this is a example’被追加到以test开头的行后面，sed要求命令a后面有一个反斜杠。 1.5.7. 插入：i命令 $ sed ‘/test/i\new line————————-‘ example如果test被匹配，则把反斜杠后面的文本插入到匹配行的前面。下一个：n命令 $ sed ‘/test/{ n; s/aa/bb/; }’ example—–如果test被匹配，则移动到匹配行的下一行，替换这一行的aa，变为bb，并打印该行，然后继续。变形：y命令 $ sed ‘1,10y/abcde/ABCDE/‘ example—–把1–10行内所有abcde转变为大写，注意，正则表达式元字符不能使用这个命令。退出：q命令 $ sed ‘10q’ example—–打印完第10行后，退出sed。保持和获取：h命令和G命令 $ sed -e ‘/test/h’ -e ‘$G example—–在sed处理文件的时候，每一行都被保存在一个叫模式空间的临时缓冲区中，除非行被删除或者输出被取消，否则所有被处理的行都将 打印在屏幕上。接着模式空间被清空，并存入新的一行等待处理。在这个例子里，匹配test的行被找到后，将存入模式空间，h命令将其复制并存入一个称为保 持缓存区的特殊缓冲区内。第二条语句的意思是，当到达最后一行后，G命令取出保持缓冲区的行，然后把它放回模式空间中，且追加到现在已经存在于模式空间中 的行的末尾。在这个例子中就是追加到最后一行。简单来说，任何包含test的行都被复制并追加到该文件的末尾。保持和互换：h命令和x命令 $ sed -e ‘/test/h’ -e ‘/check/x’ example —–互换模式空间和保持缓冲区的内容。也就是把包含test与check的行互换。1.5.8. 脚本Sed脚本是一个sed的命令清单，启动Sed时以-f选项引导脚本文件名。Sed对于脚本中输入的命令非常挑剔，在命令的末尾不能有任何空白或文本，如果在一行中有多个命令，要用分号分隔。以#开头的行为注释行，且不能跨行。]]></content>
      <categories>
        <category>大数据学习笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>大数据</tag>
        <tag>linux命令</tag>
        <tag>centos7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据02-03 shell编程语法讲解]]></title>
    <url>%2F2017%2F11%2F06%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2F%E5%A4%A7%E6%95%B0%E6%8D%AE02-03%20shell%E7%BC%96%E7%A8%8B%E8%AF%AD%E6%B3%95%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1. 变量1.1. 系统变量 $HOME $PWD $SHELL $USER显示当前shell中所有变量 set 1.2. 用户自定义变量定义变量 STR=”hello world” A=9 unset A 撤销变量 A readonly B=2 声明静态的变量 B=2 ，不能 unset export 变量名 可把变量提升为全局环境变量，可供其他shell程序使用 将命令的返回值赋给变量 12A=`ls -la` 反引号，运行里面的命令，并把结果返回给变量AA=$(ls -la) 等价于反引号 1.3. shell中的特殊变量 $? 表示上一个命令退出的状态 true 0 false 1 错误127 $$ 表示当前进程编号 $0 表示当前脚本名称 $n 表示n位置的输入参数（n代表数字，n&gt;=1） $# 表示参数的个数，常用于循环 $*和$@ 都表示参数列表 1.3.1. $*与$@区别 $* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号” “包含时，都以$1 $2 … $n 的形式输出所有参数 当它们被双引号” “包含时，”$*” 会将所有的参数作为一个整体，以”$1 $2 … $n”的形式输出所有参数；”$@” 会将各个参数分开，以”$1” “$2” … “$n” 的形式输出所有参数 1.4. 运算符 格式 :expr m + n 或$((m+n)) 注意expr运算符间要有空格 例如计算（2 ＋3 ）×4 的值1 .分步计算 S=expr 2 + 3 expr $S * 42.一步完成计算1234expr `expr 2 + 3 ` \* 4echo `expr \`expr 2 + 3\` \* 4`或$(((2+3)*4)) 2. for循环2.1. 第一种：12345678for N in 1 2 3do echo $Ndone或for N in 1 2 3; do echo $N; done或for N in &#123;1..3&#125;; do echo $N; done 2.2. 第二种：123456for ((i = 0; i &lt;= 5; i++))do echo "welcome $i times"done或for ((i = 0; i &lt;= 5; i++)); do echo "welcome $i times"; done 3. while循环3.1. 第一种12345while expressiondocommand…done 3.2. 第二种123456i=1while ((i&lt;=3))do echo $i let i++done 4. case语句格式12345678910case $1 instart) echo "starting" ;;stop) echo "stoping" ;;*) echo "Usage: &#123;start|stop&#125; “esac 5. read命令read -p(提示语句)-n(字符个数) -t(等待时间) read -p “please input your name: “ NAME 使用示例：12345[vagrant@mysql1 ~]$ read -p &quot;please enter a number:&quot; numbplease enter a number:1[vagrant@mysql1 ~]$ echo $numb1[vagrant@mysql1 ~]$ 6. if判断语法12345678if condition then statements[elif condition then statements. ..] [else statements ] fi 7. 判断语句[ condition ] (注意condition前后要有空格) 8. 非空返回true，可使用$?验证（0为true，&gt;1为false）[ test ] 9. 空返回false[ ] [ condition ] &amp;&amp; echo OK || echo notok 条件满足，执行后面的语句 不满足执行 || 后面的语句 10. 常用判断条件 = 字符串比较 -lt 小于 -le 小于等于 -eq 等于 -gt 大于 -ge 大于等于 -ne 不等于 -r 有读的权限 -w 有写的权限 -x 有执行的权限 -f 文件存在并且是一个常规的文件 -s 文件存在且不为空 -d 文件存在并是一个目录 -b文件存在并且是一个块设备 -L 文件存在并且是一个链接 11. Shell自定义函数语法12345 [ function ] funname [()]&#123; action; [return int;]&#125; 三种声明方式: function start() function start start() 注意 必须在调用函数地方之前，先声明函数，shell脚本是逐行运行。不会像其它语言一样先预编译 函数返回值，只能通过$? 系统变量获得，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255) 11.1. 例子12345678910#!/bin/bashfSum 3 2;function fSum()&#123; echo $1,$2; return $(($1+$2));&#125;fSum 5 7;total=$?;echo $total,$?; 结果1234[vagrant@mysql1 ~]$ sh test test: line 2: fSum: command not found5,712,0 12. 脚本调试 sh -vx helloWorld.sh 或者在脚本中增加set -x 13. cut命令cut命令可以从一个文本文件或者文本流中提取文本列。 13.1. 语法12cut -d&apos;分隔字符&apos; -f fields &lt;==用于有特定分隔字符cut -c 字符区间 &lt;==用于排列整齐的信息 -d ：后面接分隔字符。与 -f 一起使用； -f ：依据 -d 的分隔字符将一段信息分割成为数段，用 -f 取出第几段的意思； -c ：以字符 (characters) 的单位取出固定字符区间； 13.2. 例子13.2.1. PATH 变量如下123[root@www ~]# echo $PATH/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/bin:/usr/X11R6/bin:/usr/games# 1 | 2 | 3 | 4 | 5 | 6 | 7 13.2.2. 将 PATH 变量取出，我要找出第五个路径。12#echo $PATH | cut -d &apos;:&apos; -f 5/usr/local/bin 13.2.3. 将 PATH 变量取出，我要找出第三和第五个路径。12#echo $PATH | cut -d &apos;:&apos; -f 3,5/sbin:/usr/local/bin 13.2.4. 将 PATH 变量取出，我要找出第三到最后一个路径。12echo $PATH | cut -d &apos;:&apos; -f 3-/sbin:/usr/sbin:/usr/local/bin:/usr/X11R6/bin:/usr/games 13.2.5. 将 PATH 变量取出，我要找出第一到第三个路径。12#echo $PATH | cut -d &apos;:&apos; -f 1-3/bin:/usr/bin:/sbin: 13.2.6. 将 PATH 变量取出，我要找出第一到第三，还有第五个路径。12echo $PATH | cut -d &apos;:&apos; -f 1-3,5/bin:/usr/bin:/sbin:/usr/local/bin 13.3. 实用例子:只显示/etc/passwd的用户和shell1234#cat /etc/passwd | cut -d &apos;:&apos; -f 1,7 root:/bin/bashdaemon:/bin/shbin:/bin/sh 14. sort命令sort 命令对 File 参数指定的文件中的行排序，并将结果写到标准输出。如果 File 参数指定多个文件，那么 sort 命令将这些文件连接起来，并当作一个文件进行排序。 14.1. 语法[root@www ~]# sort [-fbMnrtuk] [file or stdin]选项与参数： -f ：忽略大小写的差异，例如 A 与 a 视为编码相同； -b ：忽略最前面的空格符部分； -M ：以月份的名字来排序，例如 JAN, DEC 等等的排序方法； -n ：使用『纯数字』进行排序(默认是以文字型态来排序的)； -r ：反向排序； -u ：就是 uniq ，相同的数据中，仅出现一行代表； -t ：分隔符，默认是用 [tab] 键来分隔； -k ：以那个区间 (field) 来进行排序的意思 14.2. 对/etc/passwd 的账号进行排序12345[root@www ~]# cat /etc/passwd | sortadm:x:3:4:adm:/var/adm:/sbin/nologinapache:x:48:48:Apache:/var/www:/sbin/nologinbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologin sort 是默认以第一个数据来排序，而且默认是以字符串形式来排序,所以由字母 a 开始升序排序。 14.3. /etc/passwd 内容是以 : 来分隔的，我想以第三栏来排序，该如何123456[root@www ~]# cat /etc/passwd | sort -t &apos;:&apos; -k 3root:x:0:0:root:/root:/bin/bashuucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologinbin:x:1:1:bin:/bin:/sbin/nologingames:x:12:100:games:/usr/games:/sbin/nologin 14.4. 默认是以字符串来排序的，如果想要使用数字排序：1234cat /etc/passwd | sort -t &apos;:&apos; -k 3nroot:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/bin/shbin:x:2:2:bin:/bin:/bin/sh 14.5. 默认是升序排序，如果要倒序排序，如下12345cat /etc/passwd | sort -t &apos;:&apos; -k 3nrnobody:x:65534:65534:nobody:/nonexistent:/bin/shntp:x:106:113::/home/ntp:/bin/falsemessagebus:x:105:109::/var/run/dbus:/bin/falsesshd:x:104:65534::/var/run/sshd:/usr/sbin/nologin 14.6. 如果要对/etc/passwd,先以第六个域的第2个字符到第4个字符进行正向排序，再基于第一个域进行反向排序。12345cat /etc/passwd | sort -t&apos;:&apos; -k 6.2,6.4 -k 1r sync:x:4:65534:sync:/bin:/bin/syncproxy:x:13:13:proxy:/bin:/bin/shbin:x:2:2:bin:/bin:/bin/shsys:x:3:3:sys:/dev:/bin/sh 14.7. 查看/etc/passwd有多少个shell:对/etc/passwd的第七个域进行排序，然后去重:123456cat /etc/passwd | sort -t&apos;:&apos; -k 7 -uroot:x:0:0:root:/root:/bin/bashsyslog:x:101:102::/home/syslog:/bin/falsedaemon:x:1:1:daemon:/usr/sbin:/bin/shsync:x:4:65534:sync:/bin:/bin/syncsshd:x:104:65534::/var/run/sshd:/usr/sbin/nologin 15. uniq去重命令 uniq命令可以去除排序过的文件中的重复行，因此uniq经常和sort合用。也就是说，为了使uniq起作用，所有的重复行必须是相邻的。 15.1. uniq语法[root@www ~]# uniq [-icu]选项与参数： -i ：忽略大小写字符的不同； -c ：进行计数 -u ：只显示唯一的行 testfile的内容如下1234567cat testfilehelloworldfriendhelloworldhello 直接删除未经排序的文件，将会发现没有任何行被删除1234567#uniq testfile helloworldfriendhelloworldhello 排序文件，默认是去重1234#cat testfile | sort |uniqfriendhelloworld 排序之后删除了重复行，同时在行首位置输出该行重复的次数1234#sort testfile | uniq -c1 friend3 hello2 world 仅显示存在重复的行，并在行首显示该行重复的次数123#sort testfile | uniq -dc3 hello2 world 仅显示不重复的行12sort testfile | uniq -ufriend 16. wc命令16.1. 语法[root@www ~]# wc [-lwm]选项与参数： -l ：仅列出行； -w ：仅列出多少字(英文单字)； -m ：多少字符；16.2. 默认使用wc统计/etc/passwd 123#wc /etc/passwd40 45 1719 /etc/passwd40是行数，45是单词数，1719是字节数 wc的命令比较简单使用，每个参数使用如下： 12345678#wc -l /etc/passwd #统计行数，在对记录数时，很常用40 /etc/passwd #表示系统有40个账户#wc -w /etc/passwd #统计单词出现次数45 /etc/passwd#wc -m /etc/passwd #统计文件的字符数1719]]></content>
      <categories>
        <category>大数据学习笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>大数据</tag>
        <tag>linux命令</tag>
        <tag>centos7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux笔记-修改语言]]></title>
    <url>%2F2017%2F11%2F05%2F%E6%9D%82%E8%AE%B0%2Flinux%E7%AC%94%E8%AE%B0-%E4%BF%AE%E6%94%B9%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[1. 版本centos7 2. 查看系统是否有安装中文语言包 （列出所有可用的公共语言环境的名称，包含有zh_CN）123456[vagrant@mysql1 ~]$ locale -a |grep &quot;zh_CN&quot;zh_CNzh_CN.gb18030zh_CN.gb2312zh_CN.gbkzh_CN.utf8 若发现以上几项，说明系统已安装中文语言包，无需再安装 3. 安装中文包1root@iZj6cbstl2n6r280a27eppZ tmp]# yum groupinstall &quot;fonts&quot; 4. 修改i18n国际化和locale.conf本土化配置文件4.1. 先查看系统语言环境123456789101112131415[vagrant@mysql1 ~]$ localeLANG=en_US.UTF-8LC_CTYPE=&quot;en_US.UTF-8&quot;LC_NUMERIC=&quot;en_US.UTF-8&quot;LC_TIME=&quot;en_US.UTF-8&quot;LC_COLLATE=&quot;en_US.UTF-8&quot;LC_MONETARY=&quot;en_US.UTF-8&quot;LC_MESSAGES=&quot;en_US.UTF-8&quot;LC_PAPER=&quot;en_US.UTF-8&quot;LC_NAME=&quot;en_US.UTF-8&quot;LC_ADDRESS=&quot;en_US.UTF-8&quot;LC_TELEPHONE=&quot;en_US.UTF-8&quot;LC_MEASUREMENT=&quot;en_US.UTF-8&quot;LC_IDENTIFICATION=&quot;en_US.UTF-8&quot;LC_ALL= 4.2. 修改配置文件123vi /etc/locale.conf 或vi /etc/sysconfig/i18n (有些帖子上说修改这个,但是我的linux没有这个文件) 虽然安装了中文语言包但本机的语言环境并不是中文，先修改i18n配置文件 123456789101112[root@iZj6cbstl2n6r280a27eppZ sysconfig]# vim /etc/sysconfig/i18nLANG=&quot;zh_CN.UTF-8&quot;LC_ALL=&quot;zh_CN.UTF-8&quot;[root@iZj6cbstl2n6r280a27eppZ sysconfig]# source /etc/sysconfig/i18n[root@iZj6cbstl2n6r280a27eppZ sysconfig]# vim /etc/locale.confLANG=&quot;zh_CN.UTF-8&quot; [root@iZj6cbstl2n6r280a27eppZ sysconfig]# source /etc/locale.conf]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vagrant 创建virtualBox虚拟机]]></title>
    <url>%2F2017%2F11%2F04%2F%E6%9D%82%E8%AE%B0%2Fvagrant%20%E5%88%9B%E5%BB%BAvirtualBox%E8%99%9A%E6%8B%9F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[1. 安装vagrant1.1. 本机环境系统环境 ： win10 64 系统 1.2. 软件及镜像vagrant 官网 https://www.vagrantup.com/vagrant 需要依赖虚拟机 我用的 virtualBoxvirtualBox 官网 https://www.virtualbox.org/virtualBox 镜像 在vagrant官网中可以下载镜像下载 http://www.vagrantbox.es/ 由于国内下载比较慢，已分享到百度云 名称 类型 分享链接 vagrant_1.9.5.msi 软件 http://pan.baidu.com/s/1kVzFP1H VirtualBox-5.1.22-115126-Win.exe 软件 http://pan.baidu.com/s/1jIQgl6m centos-7.0-x86_64.box 镜像文件 http://pan.baidu.com/s/1o7Zlspk gparted-live-0.28.1-1-i686.iso 32位分区live-cd http://pan.baidu.com/s/1jISiee6 gparted-live-0.28.1-1-amd64.iso 64位分区live-cd http://pan.baidu.com/s/1dFenvvb 上面的gparted iso 文件是分区用的不过没有用到，下载不容易就一块传上来了。 1.3. 更改vagrant 存放box的位置默认vagrant 添加的box 默认存放位置为 C:\Users\当前用户名\ .vagrant.d\boxes\ 可以通过添加环境变量 VAGRANT_HOME 修改存放位置 例如：VAGRANT_HOME = D:\Program Files\VagrantHome 1.4. 更改virtualBox 存放镜像目录默认目录 C:\Users\当前用户名\VirtualBox VMs 可以在virtualBox 软件 &gt; 管理 &gt; 全局设置 &gt; 常规 &gt; 默认虚拟电脑位置进行修改 我修改为 D:\VirtualBoxVMs 2. 启动vagrant2.1. 添加boxvagrant box add centos7 E:\软件安装包\centos-7.0-x86_64.box 查看已添加的box vagrant box list D:\vagrantSpace&gt;vagrant box list centos7 (virtualbox, 0) 2.2. 初始化在准备存放vagrant配置文件的文件夹中执行 vagrant init 会生成 Vagrantfile 文件文件中包含vagrant 配置信息其中有一些配置项的说明 config.vm.box = &quot;base&quot; 修改base 为centos7 即 boxlist 中的名字 config.vm.synced_folder &quot;E:\&quot;, &quot;/vagrant_data&quot; 共享文件夹 其他配置请自行百度 2.2.1. vagrant 配置文件下面的是我的配置 # -*- mode: ruby -*- # vi: set ft=ruby : Vagrant.configure(&quot;2&quot;) do |config| config.vm.box = &quot;centos7&quot; config.vm.define :java do |java| java.vm.provider &quot;virtualbox&quot; do |v| v.customize [&quot;modifyvm&quot;, :id, &quot;--name&quot;, &quot;java&quot;, &quot;--memory&quot;, &quot;512&quot;] end java.vm.box = &quot;centos7&quot; java.vm.hostname = &quot;java&quot; java.vm.network :private_network, ip: &quot;192.168.33.10&quot; end config.vm.define :linux do |linux| linux.vm.provider &quot;virtualbox&quot; do |v| v.customize [&quot;modifyvm&quot;, :id, &quot;--name&quot;, &quot;linux&quot;, &quot;--memory&quot;, &quot;512&quot;] end linux.vm.box = &quot;centos7&quot; linux.vm.hostname = &quot;linux&quot; linux.vm.network :private_network, ip: &quot;192.168.33.11&quot; end end 2.3. 启动虚拟机 vagrant up linux 第一次会初始化虚拟机,并启动,成功后查看虚拟机运行状态 vagrant global-status D:\vagrantSpace&gt;vagrant global-status id name provider state directory ----------------------------------------------------------------------- 1d24610 linux virtualbox running D:/vagrantSpace 这个时候就可以通过ssh登录虚拟机了。默认用户和密码都是 vagrant 下面是修改磁盘大小,如果觉得没有必要,可以不修改,直接玩就可以啦 3. 修改虚拟机磁盘大小vagrant 默认创建的磁盘 根目录下只有10G.觉得太小,修改为1T. 关闭 linux vagrant halt linux 进入到 D:\VirtualBoxVMs文件夹下 即 之前设置的virtualBox的路径,里面会有个刚才创建的linux系统的文件夹 D:\VirtualBoxVMs\linux 加入virtualBox 安装目录加入环境变量path 安装virtualBox后会自动加入 VBOX_MSI_INSTALL_PATH 环境变量,直接把这个路径加到path后面即可. %VBOX_MSI_INSTALL_PATH% 通过下面命令 复制一份磁盘文件, .vmdk 文件直接修改大小会报错 vboxmanage clonehd box-disk1.vmdk box.vdi –format vdi D:\VirtualBoxVMs\linux&gt;vboxmanage clonehd box-disk1.vmdk box.vdi --format vdi 0%...10%...20%...30%...40%...50%...60%...70%...80%...90%...100% Clone medium created in format &apos;vdi&apos;. UUID: 1431c156-a3b1-4374-b196-36450edecd9e 修改vdi 文件大小,命令如下 vboxmanage modifyhd box.vdi –resize 1048576 D:\VirtualBoxVMs\linux&gt;vboxmanage modifyhd box.vdi --resize 1048576 0%...10%...20%...30%...40%...50%...60%...70%...80%...90%...100% 打开虚拟机,修改 linux 磁盘文件为 box.vdi 修改后 查看D:\VirtualBoxVMs\linux 文件夹下linux.vbox 文件删除 原来的harddisk 1&lt;HardDisk uuid=&quot;&#123;3417d3e1-fcfd-410c-8df6-adba5f8b01bb&#125;&quot; location=&quot;box-disk1.vmdk&quot; format=&quot;VMDK&quot; type=&quot;Normal&quot;/&gt; 保留新的harddisk1&lt;HardDisk uuid=&quot;&#123;417759f6-4e5d-4a45-9ce1-1351b15c5a7d&#125;&quot; location=&quot;box-linux.vdi&quot; format=&quot;VDI&quot; type=&quot;Normal&quot;/&gt; 删除原来的磁盘文件, box-disk1.vmdk。这个可以以后再删除也可以，防止操作中出现什么错误。 启动虚拟机 vagrant up linux 切换到root，密码为vagrant su 查看磁盘 fdisk -l Gerät boot. Anfang Ende Blöcke Id System /dev/sda1 * 2048 1026047 512000 83 Linux /dev/sda2 1026048 20766719 9870336 8e Linux LVM 可以看到一共还是10G,并不是1T,我们需要加一个磁盘sda3 fdisk /dev/sda n p 3 回车 回车 更改磁盘类型为 lvm t 3 8e 查看磁盘 p 全部操作如下 Befehl (m für Hilfe): n Partition type: p primary (2 primary, 0 extended, 2 free) e Erweiterte Select (default p): p Partitionsnummer (3,4, default 3): 3 Erster Sektor (20766720-2147483647, Vorgabe: 20766720): Benutze den Standardwert 20766720 Last Sektor, +Sektoren or +size{K,M,G} (20766720-2147483647, Vorgabe: 2147483647): Benutze den Standardwert 2147483647 Partition 3 of type Linux and of size 1014,1 GiB is set Befehl (m für Hilfe): t Partitionsnummer (1-3, default 3): 3 Hex code (type L to list all codes): 8e Changed type of partition &apos;Linux&apos; to &apos;Linux LVM&apos; Befehl (m für Hilfe): p Disk /dev/sda: 1099.5 GB, 1099511627776 bytes, 2147483648 sectors Units = Sektoren of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk label type: dos Disk identifier: 0x00095a8e Gerät boot. Anfang Ende Blöcke Id System /dev/sda1 * 2048 1026047 512000 83 Linux /dev/sda2 1026048 20766719 9870336 8e Linux LVM /dev/sda3 20766720 2147483647 1063358464 8e Linux LVM 保存退出 w 重启虚拟机 reboot 查看当前 Volume Group vgdisplay 信息如下 [root@linux vagrant]# vgdisplay --- Volume group --- VG Name centos System ID Format lvm2 Metadata Areas 1 Metadata Sequence No 3 VG Access read/write VG Status resizable MAX LV 0 Cur LV 2 Open LV 2 Max PV 0 Cur PV 1 Act PV 1 VG Size 9,41 GiB PE Size 4,00 MiB Total PE 2409 Alloc PE / Size 2399 / 9,37 GiB Free PE / Size 10 / 40,00 MiB VG UUID NJWfOH-An0K-Hm9Q-8Tjs-yq2x-ZWXi-L2vP7i 名称为 centos，可调整大小（resizable），当前大小为 9,41GB。活动的 LVM 卷有 lvscan [root@linux vagrant]# lvscan ACTIVE &apos;/dev/centos/swap&apos; [1016,00 MiB] inherit ACTIVE &apos;/dev/centos/root&apos; [8,38 GiB] inherit 先将分配过来的新磁盘空间创建为一个新的物理卷 pvcreate /dev/sda3 [root@linux vagrant]# pvcreate /dev/sda3 Physical volume &quot;/dev/sda3&quot; successfully created 然后使用新的物理卷来扩展 LVM 的 centos vgextend centos /dev/sda3 [root@linux vagrant]# vgextend centos /dev/sda3 Volume group &quot;centos&quot; successfully extended 然后扩展 LVM 的逻辑卷 centos-lv_root lvextend /dev/centos/root /dev/sda3 [root@linux vagrant]# lvextend /dev/centos/root /dev/sda3 Size of logical volume centos/root changed from 8,38 GiB (2145 extents) to 1022,47 GiB (261753 extents). Logical volume root successfully resized 最后，调整逻辑卷文件系统的大小 vagrant]# resize2fs /dev/centos/root [root@linux vagrant]# resize2fs /dev/centos/root resize2fs 1.42.9 (28-Dec-2013) resize2fs: Ungültige magische Zahl im Superblock beim Versuch, /dev/centos/root zu öffnen Kann keinen gültigen Dateisystem-Superblock finden. 完成。看看效果,可以看到root下变成了1T lvscan [root@linux vagrant]# lvscan ACTIVE &apos;/dev/centos/swap&apos; [1016,00 MiB] inherit ACTIVE &apos;/dev/centos/root&apos; [1022,47 GiB] inherit 但是,查看根目录下面分配大小, 跟目录还是为8.4G [root@linux vagrant]# df -h Dateisystem Größe Benutzt Verf. Verw% Eingehängt auf /dev/mapper/centos-root 8,4G 1,1G 7,4G 13% / devtmpfs 236M 0 236M 0% /dev tmpfs 245M 0 245M 0% /dev/shm tmpfs 245M 4,3M 241M 2% /run tmpfs 245M 0 245M 0% /sys/fs/cgroup /dev/sda1 497M 118M 379M 24% /boot 用 xfs_growfs 对扩容后的 LV 进行 xfs 格式大小调整 xfs_growfs /dev/centos/root [root@linux vagrant]# xfs_growfs /dev/centos/root meta-data=/dev/mapper/centos-root isize=256 agcount=4, agsize=549120 blks = sectsz=512 attr=2, projid32bit=1 = crc=0 finobt=0 data = bsize=4096 blocks=2196480, imaxpct=25 = sunit=0 swidth=0 blks naming =version 2 bsize=4096 ascii-ci=0 ftype=0 log =Intern bsize=4096 blocks=2560, version=2 = sectsz=512 sunit=0 blks, lazy-count=1 realtime =keine extsz=4096 blocks=0, rtextents=0 Datenblöcke von 2196480 auf 268035072 geändert. 再查看 [root@linux vagrant]# df -h Dateisystem Größe Benutzt Verf. Verw% Eingehängt auf /dev/mapper/centos-root 1023G 1,1G 1022G 1% / devtmpfs 236M 0 236M 0% /dev tmpfs 245M 0 245M 0% /dev/shm tmpfs 245M 4,3M 241M 2% /run tmpfs 245M 0 245M 0% /sys/fs/cgroup /dev/sda1 497M 118M 379M 24% /boot 可以看到根目录大小已经变成1T了 http://pan.baidu.com/s/1dEC3ePr 由于不了解linux,修改磁盘大小费了很多事.完成后打了包,做成了新的box，方便以后直接使用。 4. 其他4.1. 修改linux 语言 /etc/locale.conf1LANG=&apos;en_US.UTF-8&apos; 5. 参考博客:5.1. 调整 VirtualBox 虚拟机的磁盘大小https://cnzhx.net/blog/resizing-lvm-centos-virtualbox-guest/ 5.2. 手把手教你给 CentOS 7 添加硬盘及扩容(LVM)https://aurthurxlc.github.io/Aurthur-2017/Centos-7-extend-lvm-volume.html]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vagrant</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7 安装mysql-转]]></title>
    <url>%2F2017%2F11%2F04%2F%E6%9D%82%E8%AE%B0%2Fcentos7-%E5%AE%89%E8%A3%85mysql-%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[linux下安装Mysql 1. 其他1.1. 错误1.1.1. 本地登陆不进去12#mysql -u root -p 提示”Access denied for user ‘root’@’localhost’ (using password: YES)” 我的mysql版本 mysql Ver 14.14 Distrib 5.6.38 先修改一下mysql安装目录下面my.cnf,最后一行添加 skip-grant-tables然后登陆 进去修改 update mysql.user set password=password(‘mypassword’) where user=’root’; 退出,修改文件删除刚加的属性,重启mysql服务 1.1.2. 远程连接 ip无权限 update mysql.user set host=’%’ where user=’root’;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>大数据</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FTP服务器简单创建]]></title>
    <url>%2F2017%2F11%2F04%2F%E6%9D%82%E8%AE%B0%2Fftp%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[1. FTP服务器简单创建1.1. １.环境CentOS release 6.5 (Final)-amd64 查看linux版本: [root@localhost vsftpd]# cat /etc/issueCentOS release 6.5 (Final)Kernel \r on an \m[root@localhost vsftpd]# lsb_release -aLSB Version: :base-4.0-amd64:base-4.0-noarch:core-4.0-amd64:core-4.0-noarch:graphics-4.0-amd64:graphics-4.0-noarch:printing-4.0-amd64:printing-4.0-noarchDistributor ID: CentOSDescription: CentOS release 6.5 (Final)Release: 6.5Codename: Final 1.2. 安装vsftpd 安装vsftpd yum install vsftpd 安装成功后查看 [root@localhost vsftpd]# rpm -qa |grep vsftpdvsftpd-2.2.2-21.el6.x86_64 开启ftp服务 [root@localhost vsftpd]# service vsftpd start为 vsftpd 启动 vsftpd： [确定] 停止ftp服务 [root@localhost vsftpd]# service vsftpd stop关闭 vsftpd： [确定] 1.3. 创建用户 专门创建一个ftp链接的用户，限制其只能通过ftp方式登录，只能访问指定给他的目录。 1.3.1. 创建用户 创建分组,用于存放ftp用户(可以省略) groupadd ftpgroups 创建ftp用户，并加入ftpgroups组，/home/ftp是自己建的目录，不存在就自己创建一个(目录自己定义) useradd -d /home/ftp/ftptest -g ftpgroups ftptest -d 后面是指定用户目录的 -g 分配所属组 (如果没创建上面的组 可以省略-g 及后面的组名 ftpgroups) 给用户授权文件夹的写权限(我做的需要上传文件) chmod -R 755 /home/ftp 1.3.2. 设置密码 passwd ftptest 输入两次密码 1.3.3. 设置不允许用于登录 usermod -s /sbin/nologin ftptest 没设置这个的时候,虽然没有ssh的登录权限,但是用xshell链接的时候会进入~bash对其他文件进行操作. 1.4. 配置vsftpd 安装vsftpd之后,在/etc/vsftpd 下有三个配置文件: -rw——- 1 root root 125 2月 8 14:46 ftpusers-rw——- 1 root root 384 2月 8 15:35 user_list-rw——- 1 root root 4765 2月 8 16:35 vsftpd.conf-rwxr–r– 1 root root 338 5月 11 2016 vsftpd_conf_migrate.sh 1.4.1. 配置文件 ftpusers 可以简单理解为黑名单,其中的用户不能访问ftp,总是生效的 user_list 与 vsftpd.conf中的配置userlist_enable=YES 和 userlist_deny=NO功能使用,可以设置成黑名单,白名单(只有此文件里的用户才能使用ftp),具体设置看下面 vsftpd.conf 主配置文件 修改一下配置文件让其只能访问自身目录 vi /etc/vsftpd/vsftpd.conf 如下设置 chroot_local_user=YESchroot_list_enable=YESchroot_list_file=/etc/vsftpd/chroot_list chroot_list 文件自己创建，如果需要让某些用户可以访问其他目录，就把用户加到这个文件中 解释一下userlist_enable=YES,userlist_deny=NOuserlist_enable 为YES时user_list文件有效,NO 则不生效userlist_deny 为YES时user_list文件为黑名单,NO为白名单 通过配置指定user_list userlist_file=/etc/vsftpd/user_list 2. 我的配置ftpusers 不变chroot_list 创建了内容为空user_list 修改为 # vsftpd userlist # If userlist_deny=NO, only allow users in this file # If userlist_deny=YES (default), never allow users in this file, and # do not even prompt for a password. # Note that the default vsftpd pam config also checks /etc/vsftpd/ftpusers # for users that are denied. #root #bin #daemon #adm #lp #sync #shutdown #halt #mail #news #uucp #operator #games #nobody ftptest vsftpd.conf修改为 # Example config file /etc/vsftpd/vsftpd.conf # # The default compiled in settings are fairly paranoid. This sample file # loosens things up a bit, to make the ftp daemon more usable. # Please see vsftpd.conf.5 for all compiled in defaults. # # READ THIS: This example file is NOT an exhaustive list of vsftpd options. # Please read the vsftpd.conf.5 manual page to get a full idea of vsftpd&apos;s # capabilities. # # Allow anonymous FTP? (Beware - allowed by default if you comment this out). anonymous_enable=NO # # Uncomment this to allow local users to log in. local_enable=YES # # Uncomment this to enable any form of FTP write command. write_enable=YES # # Default umask for local users is 077. You may wish to change this to 022, # if your users expect that (022 is used by most other ftpd&apos;s) local_umask=022 # # Uncomment this to allow the anonymous FTP user to upload files. This only # has an effect if the above global write enable is activated. Also, you will # obviously need to create a directory writable by the FTP user. #anon_upload_enable=YES # # Uncomment this if you want the anonymous FTP user to be able to create # new directories. #anon_mkdir_write_enable=YES # # Activate directory messages - messages given to remote users when they # go into a certain directory. dirmessage_enable=YES # # The target log file can be vsftpd_log_file or xferlog_file. # This depends on setting xferlog_std_format parameter xferlog_enable=YES # # Make sure PORT transfer connections originate from port 20 (ftp-data). connect_from_port_20=YES # # If you want, you can arrange for uploaded anonymous files to be owned by # a different user. Note! Using &quot;root&quot; for uploaded files is not # recommended! #chown_uploads=YES #chown_username=whoever # # The name of log file when xferlog_enable=YES and xferlog_std_format=YES # WARNING - changing this filename affects /etc/logrotate.d/vsftpd.log #xferlog_file=/var/log/xferlog # # Switches between logging into vsftpd_log_file and xferlog_file files. # NO writes to vsftpd_log_file, YES to xferlog_file xferlog_std_format=YES # # You may change the default value for timing out an idle session. #idle_session_timeout=600 # # You may change the default value for timing out a data connection. #data_connection_timeout=120 # # It is recommended that you define on your system a unique user which the # ftp server can use as a totally isolated and unprivileged user. #nopriv_user=ftpsecure # # Enable this and the server will recognise asynchronous ABOR requests. Not # recommended for security (the code is non-trivial). Not enabling it, # however, may confuse older FTP clients. #async_abor_enable=YES # # By default the server will pretend to allow ASCII mode but in fact ignore # the request. Turn on the below options to have the server actually do ASCII # mangling on files when in ASCII mode. # Beware that on some FTP servers, ASCII support allows a denial of service # attack (DoS) via the command &quot;SIZE /big/file&quot; in ASCII mode. vsftpd # predicted this attack and has always been safe, reporting the size of the # raw file. # ASCII mangling is a horrible feature of the protocol. #ascii_upload_enable=YES #ascii_download_enable=YES # # You may fully customise the login banner string: #ftpd_banner=Welcome to blah FTP service. # # You may specify a file of disallowed anonymous e-mail addresses. Apparently # useful for combatting certain DoS attacks. #deny_email_enable=YES # (default follows) #banned_email_file=/etc/vsftpd/banned_emails # # You may specify an explicit list of local users to chroot() to their home # directory. If chroot_local_user is YES, then this list becomes a list of # users to NOT chroot(). #chroot_local_user=YES #chroot_list_enable=YES # (default follows) #chroot_list_file=/etc/vsftpd/chroot_list # # You may activate the &quot;-R&quot; option to the builtin ls. This is disabled by # default to avoid remote users being able to cause excessive I/O on large # sites. However, some broken FTP clients such as &quot;ncftp&quot; and &quot;mirror&quot; assume # the presence of the &quot;-R&quot; option, so there is a strong case for enabling it. #ls_recurse_enable=YES # # When &quot;listen&quot; directive is enabled, vsftpd runs in standalone mode and # listens on IPv4 sockets. This directive cannot be used in conjunction # with the listen_ipv6 directive. listen=YES # # This directive enables listening on IPv6 sockets. To listen on IPv4 and IPv6 # sockets, you must run two copies of vsftpd with two configuration files. # Make sure, that one of the listen options is commented !! #listen_ipv6=YES pam_service_name=vsftpd userlist_enable=YES tcp_wrappers=YES userlist_deny=NO userlist_file=/etc/vsftpd/user_list chroot_local_user=YES chroot_list_enable=YES chroot_list_file=/etc/vsftpd/chroot_list 3. JAVA上传下载3.1. java需要的jarcommons-io-2.1.jarcommons-net-1.4.1.jar 3.2. java代码demopackage ftp; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import org.apache.commons.io.IOUtils; import org.apache.commons.net.ftp.FTPClient; public class FtpTest1 { public static void main(String[] args) { testUpload(); testDownload(); } /** * FTP上传单个文件测试 */ public static void testUpload() { FTPClient ftpClient = new FTPClient(); FileInputStream fis = null; try { ftpClient.connect(&quot;192.168.0.1&quot;); System.out.print(ftpClient.getReplyString()); ftpClient.login(&quot;username&quot;, &quot;password&quot;); System.out.println(ftpClient.getReplyCode() + ftpClient.getReplyString()); File srcFile = new File(&quot;C:\\Users\\jk\\Desktop\\img.jpg&quot;); System.out.println(srcFile.exists()); fis = new FileInputStream(srcFile); //设置上传目录 ftpClient.changeWorkingDirectory(&quot;/admin&quot;); System.out.println(ftpClient.getReplyCode() + ftpClient.getReplyString()); ftpClient.setBufferSize(1024); System.out.println(ftpClient.getReplyCode() + ftpClient.getReplyString()); ftpClient.setControlEncoding(&quot;GBK&quot;); System.out.println(ftpClient.getReplyCode() + ftpClient.getReplyString()); //设置文件类型（二进制） ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE); System.out.println(ftpClient.getReplyCode() + ftpClient.getReplyString()); ftpClient.storeFile(&quot;5.gif&quot;, fis); System.out.println(ftpClient.getReplyCode() + ftpClient.getReplyString()); } catch (IOException e) { e.printStackTrace(); throw new RuntimeException(&quot;FTP客户端出错！&quot;, e); } finally { IOUtils.closeQuietly(fis); try { ftpClient.disconnect(); } catch (IOException e) { e.printStackTrace(); throw new RuntimeException(&quot;关闭FTP连接发生异常！&quot;, e); } } } /** * FTP下载单个文件测试 */ public static void testDownload() { FTPClient ftpClient = new FTPClient(); FileOutputStream fos = null; try { ftpClient.connect(&quot;192.168.0.1&quot;); System.out.print(ftpClient.getReplyString()); ftpClient.login(&quot;username&quot;, &quot;password&quot;); System.out.print(ftpClient.getReplyString()); String remoteFileName = &quot;/3.gif&quot;; fos = new FileOutputStream(&quot;C:/Users/jk/Desktop/3.jpg&quot;); ftpClient.setBufferSize(1024); System.out.print(ftpClient.getReplyString()); //设置文件类型（二进制） ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE); System.out.print(ftpClient.getReplyString()); ftpClient.retrieveFile(remoteFileName, fos); System.out.print(ftpClient.getReplyString()); } catch (IOException e) { e.printStackTrace(); throw new RuntimeException(&quot;FTP客户端出错！&quot;, e); } finally { IOUtils.closeQuietly(fos); try { ftpClient.disconnect(); System.out.print(ftpClient.getReplyString()); } catch (IOException e) { e.printStackTrace(); throw new RuntimeException(&quot;关闭FTP连接发生异常！&quot;, e); } } } } 3.3. 其他（我没有用到,服务器之前就用着）如果还是登陆不了ftp，那很有可能是selinux的问题，这个东西把他关掉就行 vi /etc/selinux/config SELINUX=enforcing 设置成SELINUX=disabled 重启一下服务器 reboot 重启完了别忘了把vsftpd服务打开，默认是自启的。 如果连接不上，很可能是防火墙阻止了，尝试关闭防火墙 systemctl stop firewalld.service #停止firewallsystemctl disable firewalld.service #禁止firewall开机启动firewall-cmd –state #查看默认防火墙状态（关闭后显示notrunning，开启后显示running） 如果出现远程文件夹无法显示的情况，请使用主动模式连接，在你的ftp工具上设置。 3.4. linux下ftp配置文件详解# 匿名用户配置 anonymous_enable=YES # 是否允许匿名ftp,如否则选择NO anon_upload_enable=YES # 匿名用户是否能上传 anon_mkdir_write_enable=YES # 匿名用户是否能创建目录 anon_other_write_enable=YES # 修改文件名和删除文件 # 本地用户配置 local_enable=YES # 是否允许本地用户登录 local_umask=022 # umask 默认755 write_enable=YES chroot_local_user=YES # 本地用户禁锢在宿主目录中 chroot_list_enable=YES # 是否将系统用户限止在自己的home目录下 chroot_list_file=/etc/vsftpd.chroot_list # 列出的是不chroot的用户的列表 chown_upload=YES # 是否改变上传文件的属主 chown_username=username # 如果是需要输入一个系统用户名 userlist_enable=YES userlist_deny=NO deny_email_enable=YES # 是否允许禁止匿名用户使用某些邮件地址 banned_email_file=/etc/vsftpd.banned_emails # 禁止邮件地址的文件路径 ftpd_banner=Welcome to chenlf FTP service. # 定制欢迎信息 dirmessage_enable=YES # 是否显示目录说明文件, 需要收工创建.message文件 message_file= # 设置访问一个目录时获得的目录信息文件的文件名,默认是.message xferlog_enable=YES # 是否记录ftp传输过程 xferlog_file=/var/log/vsftpd.log # ftp传输日志的路径和名字 xferlog_std_format=YES # 是否使用标准的ftp xferlog模式 ascii_upload_enable=YES # 是否使用ascii码方式上传文件 ascii_download_enable=YES # 是否使用ascii码方式下载文件 connect_from_port_20=YES # 是否确信端口传输来自20(ftp-data) nopriv_user=ftpsecure # 运行vsftpd需要的非特权系统用户默认是nobody async_abor_enable=YES # 是否允许运行特殊的ftp命令async ABOR. # FTP服务器的资源限制 idle_session_timeout=600 # 设置session超时时间 data_connection_timeout=120 # 设置数据传输超时时间 max_clients=50 # 用户最大连接数 默认是0不限止 max_per_ip=5 # 每个IP地址最大连接数 anon_max_rate=102400 # 匿名的下载速度 KB local_max_rate=102400 # 普通用户的下载速度 KB 其他配置文件 /etc/xinetd.d/vsftpd service ftp { socket_type = stream wait = no user = root server = /usr/local/sbin/vsftpd # server_args = # log_on_success += DURATION USERID # log_on_failure += USERID nice = 10 disable = no } /etc/pam.d/vsftpd PAM 认证 /etc/vsftpd.chroot_list 此文件包含对服务器上所有FTP内容有权限的用户名。对其他用户来说，他们在服务器上的主目录对他们显示为根目录。 /etc/shells 在允许本地用户登录之前，系统默认检查是否有有效的用户 shell。以防 PAM 认证不可用的情况。 /etc/ftpusers 此文件包含*禁止*FTP登录的用户名，通常有 &quot;root&quot;， &quot;uucp&quot;， &quot;news&quot; 之类，因为这些用户权限太高，登录 FTP 误操作危险性大。 防火墙设置 如果是用默认的SuSEFirewall2，在 YaST-系统-/etc/sysconfig 编辑器，network-SuSEfirewall2 把 ftp 添加到 FW_SERVICES_EXT_TCP，比如你还要打开 ssh 那么 FW_SERVICES_EXT_TCP &quot;ftp ssh&quot; 如果你需要被动模式 FTP 和 nat，在 YaST-系统-/etc/sysconfig 编辑器，network-SuSEfirewall2 FW_LOAD_MODULES &quot;ip_conntrack_ftp ip_nat_ftp&quot; 另一种方式直接修改防火墙配置文件： # cd /etc/sysconfig/ # vi SuSEfirewall2 FW_SERVICES_EXT_TCP &quot;ftp 21 telnet 23&quot;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7 开放端口]]></title>
    <url>%2F2017%2F11%2F04%2F%E6%9D%82%E8%AE%B0%2Fcentos7-%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[CentOS升级到7之后，发现无法使用iptables控制Linuxs的端口，google之后发现Centos 7使用firewalld代替了原来的iptables。下面记录如何使用firewalld开放Linux端口： 开启端口 1firewall-cmd --zone=public --add-port=80/tcp --permanent 命令含义： 12345--zone #作用域--add-port=80/tcp #添加端口，格式为：端口/通讯协议--permanent #永久生效，没有此参数重启后失效 重启防火墙 1firewall-cmd --reload 查看开启了那些端口 /sbin/iptables -L -n]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>大数据</tag>
        <tag>centos7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据02-02 linux命令继续学习 yum]]></title>
    <url>%2F2017%2F11%2F01%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2F%E5%A4%A7%E6%95%B0%E6%8D%AE02-02-linux%E5%91%BD%E4%BB%A4%E7%BB%A7%E7%BB%AD%E5%AD%A6%E4%B9%A0-yum%2F</url>
    <content type="text"><![CDATA[1. YUM的常用命令安装httpd并确认安装1yum instll -y httpd 列出所有可用的package和package组1yum list 清除所有缓冲数据1yum clean all 列出一个包所有依赖的包1yum deplist httpd 删除httpd1yum remove httpd 2. 配置本地yum源cd /etc/yum.repos.d 3. 安装jdk解压安装包 tar -zxvf jdk-7u45-linux-x64.tar.gz -C apps/ 然后修改环境变量 vi /etc/profile 在文件最后添加12export JAVA_HOME=/root/apps/jdk1.7.0_45export PATH=$PATH:$JAVA_HOME/bin 保存退出 然后重新加载环境变量 source /etc/profile 4. 装mysql5. 安装tomcat 上传tomcat包 解压 启动 测试访问]]></content>
      <categories>
        <category>大数据学习笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>大数据</tag>
        <tag>linux命令</tag>
        <tag>centos7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo next 搜索 algolia]]></title>
    <url>%2F2017%2F10%2F30%2F%E6%9D%82%E8%AE%B0%2Fhexo-next-%E6%90%9C%E7%B4%A2-algolia%2F</url>
    <content type="text"><![CDATA[1. 目的:添加搜索功能algolia似乎是试用一段时间就不能用了,建议使用本地搜索hexo-next 本地搜索 2. next版本我的版本号是12# Theme versionversion: 5.1.2 next5.0+版本集成了algolia 这样使配置algolia更简单 3. algolia账号申请Algolia官网 直接用github账号注册就好啦 创建index空间 输入一个名称,填写你自己站点的网址 创建两个key 空间创建好后默认会有一个只有搜索权限的key 需要另建一个有修改记录等权限的key(这个供我们提交索引到空间使用) 创建key的时候要选择授权的空间 记录 Application ID 两个key建 4. 安装hexo-algolia用git-bash在hexo工程根目录下执行 npm install hexo-algolia --save 5. 配置algolia 在Hexo工程根目录的_config.yml中加入如下配置，注意改成前面API Keys页面相应配置 123456algolia: applicationID: '你的Application ID' apiKey: '只有搜索权限的key' adminApiKey: '' indexName: '你的index空间名称' chunkSize: 5000 修改themes&gt;next&gt;_config.yml 搜索 algolia_search 修改enable 为true 其他字体提示可以自己随意修改 6. 添加环境变量我的电脑&gt;右键属性&gt;高级设置&gt;环境变量&gt;新建&gt;填写变量名称和变量值 变量名称 : HEXO_ALGOLIA_INDEXING_KEY 变量值: 在algolia新建的有修改权限的key 7. 生成index上传到algolia在hexo根目录执行,注意确保命令行面板已经重新载入新加的环境变量 1hexo algolia 不报错就可以啦 8. 参考NexT主题集成Algolia搜索插件Hexo集成Algolia搜索插件]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据01-linux安装及基本命令.md]]></title>
    <url>%2F2017%2F10%2F30%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2F%E5%A4%A7%E6%95%B0%E6%8D%AE01-linux%E5%AE%89%E8%A3%85%E5%8F%8A%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1. linux 文件目录 约定俗成 目录 功能 /bin 可执行文件 /sbin 系统可执行文件 /boot 跟启动相关的东西 /dev 设备 硬件 /etc 配置文件 /lib 依赖包 /lib64 依赖包 /media 一些外接设备 /mnt 挂载 /home 用户目录 /usr user share resource 公用的一些软件 /tmp 临时文件 2. linux 网络相关2.1. 网卡相关: ip ：一般 1 给网关 255是广播地址 gateway ： 网关 netmask ： 子网掩码 dns ： 2.1.1. 子网掩码是用来判断自己属于哪个网段 网段的计算:将IP地址的二进制 &amp; 子网掩码的二进制 = 网段地址例如：192.168.33.2 &amp; 255.255.255.0 = 192.168.33.0 2.1.2. dns 域名解析 从本地hosts中寻找域名 -&gt; ip映射信息 如果没有则去服务器找 访问服务器 填写: 网关地址 dns服务器 linux dns配置文件 /etc/hosts 2.2. 网络模式2.2.1. NAT模式 2.2.2. 桥接模式 2.2.3. HOST only 2.3. 修改linux ip修改主机名: vi /etc/sysconfig/network NETWORKING=yes HOSTNAME=server1.itcast.cn 修改IP地址vi /etc/sysconfig/network-scripts/ifcfg-eth0 DEVICE=eth0 TYPE=Ethernet ONBOOT=yes #是否开机启用 BOOTPROTO=static #ip地址设置为静态 IPADDR=192.168.0.101 NETMASK=255.255.255.0 修改ip地址和主机名的映射关系vi /etc/hosts 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 192.168.0.101 server1.itcast.cn 关闭iptables并设置其开机启动/不启动 service iptables stop chkconfig iptables on chkconfig iptables off 3. linux 简单命令创建文件touch somefile.1 创建一个空文本echo “i love u” &gt; somefile.2 利用重定向写入 覆盖原文件echo “i love u” &gt;&gt; somefile.2 追加 ctrl+v进入块选择模式shift+v 进入行选择模式 :%s/key/newword 查找并替换 3.1. 文件权限操作drw-r–r– d：标识节点类型（d 文件夹 - 文件 l 链接)r 可读 w可写 x可执行拥有者 所属组 其他用户 方式1 :chmod g-rw somefile.1 g 组 o 其他 u用户 +-(增加/删除权限) rwx 方式2 :chmod 700 somfile.1 文件夹及下面文件 chmod -R 770 aaa/ 修改所有者(必须要root用户)chown angela:angela aaa/ 组/用户 3.2. 基本的用户管理添加用户 useradd nagela修改密码passwd nagela 按提示输入密码即可 sudo useradd xiaobai 为用户配置sudo权限用root编辑vi /etc/sudoers在文件如下位置,为hadoop添加一行即可root ALL=(ALL) ALLhadoop ALL=(ALL) ALL 3.3. 系统管理操作1.查看主机名hostname 2.修改主机名(重启后无效)hostname hadoop 3.修改主机名(重启后永久生效)vi /ect/sysconfig/network 4.修改IP(重启后无效)ifconfig eth0 192.168.12.22 5.修改IP(重启后永久生效)vi /etc/sysconfig/network-scripts/ifcfg-eth0 6.查看系统信息uname -auname -r 7.查看ID命令id -uid -g 8.日期datedate +%Y-%m-%ddate +%Tdate +%Y-%m-%d” “%T 9.日历cal 2012 10.查看文件信息file filename 11.挂载硬盘mountumount加载windows共享mount -t cifs //192.168.1.100/tools /mnt 挂载cdrom 里面是iso镜像文件123456789101112131415mount -t iso9660 -o ro /dev/cdrom /mnt/cdrom[root@server1 mnt]# ll cdrom/total 654-rw-r--r-- 1 root root 14 Dec 5 2016 CentOS_BuildTagdrwxr-xr-x 3 root root 2048 Dec 5 2016 EFI-rw-r--r-- 1 root root 215 Dec 9 2015 EULA-rw-r--r-- 1 root root 18009 Dec 9 2015 GPLdrwxr-xr-x 3 root root 2048 Dec 5 2016 imagesdrwxr-xr-x 2 root root 2048 Dec 5 2016 isolinuxdrwxr-xr-x 2 root root 2048 Dec 5 2016 LiveOSdrwxrwxr-x 2 root root 630784 Dec 5 2016 Packagesdrwxrwxr-x 2 root root 4096 Dec 5 2016 repodata-rw-r--r-- 1 root root 1690 Dec 9 2015 RPM-GPG-KEY-CentOS-7-rw-r--r-- 1 root root 1690 Dec 9 2015 RPM-GPG-KEY-CentOS-Testing-7-r--r--r-- 1 root root 2883 Dec 5 2016 TRANS.TBL 12.查看文件大小du -hdu -ah 13.查看分区df -h 14.sshssh hadoop@192.168.1.1 15.关机shutdown -h now /init 0shutdown -r now /reboot 4. ssh免密登录 假如 A 要登陆 B在A上操作：首先生成密钥对 ssh-keygen (提示时，直接回车即可) 再将A自己的公钥拷贝并追加到B的授权列表文件authorized_keys中 ssh-copy-id B]]></content>
      <categories>
        <category>大数据学习笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>大数据</tag>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据02-01 linux命令继续学习.md]]></title>
    <url>%2F2017%2F10%2F29%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2F%E5%A4%A7%E6%95%B0%E6%8D%AE02-01%20linux%E5%91%BD%E4%BB%A4%E7%BB%A7%E7%BB%AD%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1. vmare克隆后修改地址问题解决克隆后eth0不见的问题 直接修改 /etc/sysconfig/network-script/ifcfg-eth0删掉UUID HWADDR配置静态地址然后：修改 /etc/udev/rules.d/70-persistent-net.rules然后 reboot 2. linux命令继续学习2.1. 查看文件内容cat somefile 一次性将文件内容全部输出（控制台）more somefile 可以翻页查看, 下翻一页(空格) 上翻一页（b） 退出（q）less somefile 可以翻页查看,下翻一页(空格) 上翻一页（b），上翻一行(↑) 下翻一行（↓） 可以搜索关键字（/keyword） tail -10 install.log 查看文件尾部的10行tail -f install.log 小f跟踪文件的唯一inode号，就算文件改名后，还是跟踪原来这个inode表示的文件tail -F install.log 大F按照文件名来跟踪 head -10 install.log 查看文件头部的10行 2.2. 后台服务管理service network status 查看指定服务的状态service network stop 停止指定服务service network start 启动指定服务service network restart 重启指定服务service –status-all 查看系统中所有的后台服务 2.3. 设置后台服务的自启配置chkconfig 查看所有服务器自启配置chkconfig iptables off 关掉指定服务的自动启动chkconfig iptables on 开启指定服务的自动启动 2.4. 系统启动级别管理vi /etc/inittab12345678910# Default runlevel. The runlevels used are:# 0 - halt (Do NOT set initdefault to this)# 1 - Single user mode# 2 - Multiuser, without NFS (The same as 3, if you do not have networking)# 3 - Full multiuser mode# 4 - unused# 5 - X11# 6 - reboot (Do NOT set initdefault to this)#id:3:initdefault: 3. 软件安装3.1. 如何上传安装包到服务器 可以使用图形化工具，如： filezilla 可以使用sftp工具： alt+p 调出后，用put命令上传上传（如果不cd指定目录，则上传到当前用户的主目录）：12sftp&gt; cd /home/ sftp&gt; put C:\Users\Administrator\Desktop\day02\soft\jdk-7u45-linux-x64.tar.gz 下载（lcd[local cd]指定下载到本地的目标路径）12sftp&gt; lcd d:/ sftp&gt; get /home/jdk-7u45-linux-x64.tar.gz lrzsz 3.2. 安装jdk3.2.1. 压缩解压缩的相关命令压缩解压缩 root@mini1 ~]# gzip access.log [root@mini1 ~]# ll 总用量 134892 -rw-r--r--. 1 root root 68 4月 3 17:37 access.log.gz 解压gz文件： -d access.log.gz```12### 3.2.2. 打包解包 [root@mini1 ~]# tar -cvf myfirsttarball.tar aaa/aaa/aaa/2.txtaaa/3.txtaaa/1.txt1解包： [root@mini1 ~]# tar -xvf myfirsttarball.taraaa/aaa/2.txtaaa/3.txtaaa/1.txt123### 3.2.3. 一次性完成打包&amp;&amp;压缩的操作产生压缩包： [root@mini1 ~]# tar -zcvf my.tar.gz aaa/aaa/aaa/2.txtaaa/3.txtaaa/1.txt12解压缩包： [root@mini1 ~]# tar -zxvf my.tar.gzaaa/aaa/2.txtaaa/3.txtaaa/1.txt``` 3.2.4. 安装jdk的过程： 解压安装包 tar -zxvf jdk-7u45-linux-x64.tar.gz -C apps/ 然后修改环境变量 vi /etc/profile 在文件最后添加 export JAVA_HOME=/root/apps/jdk1.7.0_45 export PATH=$PATH:$JAVA_HOME/bin 保存退出 然后重新加载环境变量 source /etc/profile 3.3. 安装rpm包软件，如mysql3.3.1. 查看系统中安装的rpm包rpm -qa | grep mysql 3.3.2. 上传rpm安装包MySQL-client-5.5.48-1.linux2.6.x86_64.rpm MySQL-server-5.5.48-1.linux2.6.x86_64.rpm per * .rpm 3.3.3. 安装perl依赖rpm -ivh perl* 可能会提示有包冲突，解决： rpm -e 冲突包名 –nodeps 3.3.4. 安装serverrpm -ivh MySQL-server-5.5.48-1.linux2.6.x86_64.rpm 如果成功，会看到进度条，最后，有关于root密码设置的提示，一定要记下来这个版本的提示是，先启动server service mysql start 然后/usr/bin/mysql_secure_installation 命令去交互式修改root密码 3.3.5. 修改密码时，提示需要先安装clientrpm -ivh MySQL-client-5.5.48-1.linux2.6.x86_64.rpm 客户端安装成功后，记得还要用/usr/bin/mysql_secure_installation 命令去交互式修改root密码 3.3.6. 登录验证mysql -uroot -proot]]></content>
      <categories>
        <category>大数据学习笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>大数据</tag>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode快捷键记录]]></title>
    <url>%2F2017%2F09%2F11%2F%E6%9D%82%E8%AE%B0%2Fvscode%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[分屏预览ctrl+k vctrl+B 唤出侧边栏 切换分屏ctrl+1ctrl+2ctrl+3 alt+z 开启/取消自动换行ctrl+` 打开/关闭控制台 文本编辑alt+↑/↓ 挪动行alt+shift+↑/↓ 向上/下复制行ctrl+enter 下方新建行ctrl+shift+enter 上方新建行ctrl+shift+k 删除当前行 ctrl+x 剪切行(光标没选中的时候)ctrl+k z 编辑区域最大化 切换窗口ctrl+e 最近打开的文件ctrl+r 打开的工作空间]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea快捷键记录]]></title>
    <url>%2F2017%2F09%2F03%2F%E6%9D%82%E8%AE%B0%2Fidea%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[查找方法,这个用于看源码的时候感觉很好用记录一下 ctrl+shift+alt+n //———————————– Navigate | Call Hierarchy命令查看一个Java方法调用树（caller和callee两个方向） ctrl+alt+H Analyze | Dataflow from/to Here两个命令查看表达式、变量和方法参数的传递关系树。 Analyze | Data Flow to HereAnalyze | Data Flow from Here “Find Usage”可以查看一个Java类、方法或变量的直接使用情况。 alt+F7 Navigate | File Structure 查看文件的结构 ctrl+F12 http://www.cnblogs.com/huaxingtianxia/p/5728847.html //———————————–]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录下hexo常用命令自己方便看]]></title>
    <url>%2F2017%2F09%2F03%2F%E6%9D%82%E8%AE%B0%2F%E8%AE%B0%E5%BD%95%E4%B8%8Bhexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%87%AA%E5%B7%B1%E6%96%B9%E4%BE%BF%E7%9C%8B%2F</url>
    <content type="text"><![CDATA[1234567Hexo常用命令： hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #将.deploy目录部署到GitHub 简写 1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 复合命令 hexo deploy -g hexo server -g 有时候生成的网页出错了，而生成的rss其实没有清除，那么用下面的命令，在重新生成吧 hexo clean]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终于有了自己的博客]]></title>
    <url>%2F2017%2F08%2F27%2F%E7%BB%88%E4%BA%8E%E6%9C%89%E4%BA%86%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[终于有了自己的博客。感谢网络，感谢爱分享的人。 搭建博客时候参考的帖子： hexo从零开始到搭建完整 Hexo安装和配置 Hexo搭建Github-Pages博客填坑教程 主题nexT使用指南 自己碰到的坑 安装hexo后启动时,访问localhost:4000网页没反应 替换端口号后解决了 rss 链接出现问题,在Hexo搭建Github-Pages博客填坑教程 中找到了解决办法 hueman 主题下载后启动错误,这个没解决,替换找别的主题了。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
